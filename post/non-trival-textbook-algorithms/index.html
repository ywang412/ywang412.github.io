<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Non-trival textbook algorithms | Yu&#39;s Github</title>
<meta name="description" content="Java by day, Scala by night">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://ywang412.github.io/favicon.ico?v=1571503461214">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://ywang412.github.io/styles/main.css">


  

  
    <link rel="stylesheet" href="https://unpkg.com/disqusjs@1.1/dist/disqusjs.css" />
  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-143424668-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-143424668-1');
</script>


  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://ywang412.github.io">
        <img src="https://ywang412.github.io/images/avatar.png?v=1571503461214" class="site-logo">
        <h1 class="site-title">Yu&#39;s Github</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            Home
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            Archive
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            Tag
          </a>
        
      
        
          <a href="/post/resume" class="site-nav">
            Resume
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/ywang412/" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      Java by day, Scala by night
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://ywang412.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">Non-trival textbook algorithms</h2>
            <div class="post-date">2018-03-31</div>
            
            <div class="post-content">
              <p><strong>229. Majority Element II  - Moore's Voting Algorithm</strong></p>
<p>The trick in Moore voting algorithm is to aggregate the top n more frequent elements when counting. If the element in iteration is not equal to any of the top n elements, the counts of each top n elements will decrease by one. Moreover, top n elements are different as a result of the initialization order.</p>
<pre><code>int first = Integer.MIN_VALUE;
int c1 = 0;
int second = Integer.MIN_VALUE;
int c2 = 0;

for (int i = 0; i &lt; nums.length; i++) {
		if (nums[i] == first) c1++;
		else if (nums[i] == second) c2++;
		else if (c1 == 0) {
						first = nums[i];
						c1 = 1;
		}
		else if (c2 == 0) {
						second = nums[i];
						c2 = 1;
				}
		else {
				c1--;
				c2--;
		}
}
</code></pre>
<p><strong>973. K Closest Points to Origin - quick find</strong></p>
<p>To find the kth smallest element, Arrays.sort() will take Nlog(N). Min priority queue can reduce it to Nlog(k). However, if we don't care about the order of the K closest points, quick find can return it in O(N) average time and O(N*N) worst time.</p>
<pre><code>class Solution {
    public int[][] kClosest(int[][] points, int K) {
        int len =  points.length, l = 0, r = len - 1;
        while (l &lt;= r) {
            int mid = helper(points, l, r);
            if (mid == K) break;
            if (mid &lt; K) {
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return Arrays.copyOfRange(points, 0, K);
    }

    private int helper(int[][] A, int l, int r) {
        int[] pivot = A[l];
        int start = l;
        while (l &lt;= r) {
            while (l &lt;= r &amp;&amp; compare(A[l], pivot) &lt;= 0) l++;
            while (l &lt;= r &amp;&amp; compare(A[r], pivot) &gt;= 0) r--;
            if (l &lt;= r) {
                int[] tmp = A[r];
                A[r] = A[l];
                A[l] = tmp;
            }
        }
        A[start] = A[r];
        A[r] = pivot;
        return r;
    }

    private int compare(int[] p1, int[] p2) {
        return p1[0] * p1[0] + p1[1] * p1[1] - p2[0] * p2[0] - p2[1] * p2[1];
    }
}
</code></pre>
<p><strong>Morris traversal</strong></p>
<p>Inorder morris traversal will visit root node right before reverting the right child change.</p>
<pre><code>class BinaryTree { 
    tNode root; 
  
    /* Function to traverse a binary tree without recursion and  
       without stack */
    void MorrisTraversal(tNode root) 
    { 
        tNode current, pre; 
  
        if (root == null) 
            return; 
  
        current = root; 
        while (current != null) { 
            if (current.left == null) { 
                System.out.print(current.data + &quot; &quot;); 
                current = current.right; 
            } 
            else { 
                /* Find the inorder predecessor of current */
                pre = current.left; 
                while (pre.right != null &amp;&amp; pre.right != current) 
                    pre = pre.right; 
  
                /* Make current as right child of its inorder predecessor */
                if (pre.right == null) { 
                    pre.right = current; 
                    current = current.left; 
                } 
  
                /* Revert the changes made in the 'if' part to restore the  
                    original tree i.e., fix the right child of predecessor*/
                else { 
                    pre.right = null; 
                    System.out.print(current.data + &quot; &quot;); 
                    current = current.right; 
                } /* End of if condition pre-&gt;right == NULL */
  
            } /* End of if condition current-&gt;left == NULL*/
  
        } /* End of while */
    } 
}
</code></pre>
<p>Pre-order morris traversal will visit root node during right before the right child change.</p>
<pre><code>class BinaryTree { 
      
    Node root; 
      
    void morrisTraversalPreorder() 
    { 
        morrisTraversalPreorder(root); 
    } 
  
    // Preorder traversal without recursion and without stack 
    void morrisTraversalPreorder(Node node) { 
        while (node != null) { 
  
            // If left child is null, print the current node data. Move to 
            // right child. 
            if (node.left == null) { 
                System.out.print(node.data + &quot; &quot;); 
                node = node.right; 
            } else { 
  
                // Find inorder predecessor 
                Node current = node.left; 
                while (current.right != null &amp;&amp; current.right != node) { 
                    current = current.right; 
                } 
  
                // If the right child of inorder predecessor  
                // already points to this node 
                if (current.right == node) { 
                    current.right = null; 
                    node = node.right; 
                } 
   
                // If right child doesn't point to this node, then print 
                // this node and make right child point to this node 
                else { 
                    System.out.print(node.data + &quot; &quot;); 
                    current.right = node; 
                    node = node.left; 
                } 
            } 
        } 
    } 
}
</code></pre>
<p><strong>Segment Tree</strong></p>
<p>Representation of Segment trees</p>
<ol>
<li>Leaf Nodes are the elements of the input array.</li>
<li>Each internal node represents some merging of the leaf nodes. The merging may be different for different problems.</li>
</ol>
<pre><code>public class NumArray {

    class SegmentTreeNode {
        int start, end;
        SegmentTreeNode left, right;
        int sum;

        public SegmentTreeNode(int start, int end) {
            this.start = start;
            this.end = end;
            this.left = null;
            this.right = null;
            this.sum = 0;
        }
    }
      
    SegmentTreeNode root = null;
   
    public NumArray(int[] nums) {
        root = buildTree(nums, 0, nums.length-1);
    }

    private SegmentTreeNode buildTree(int[] nums, int start, int end) {
        if (start &gt; end) {
            return null;
        } else {
            SegmentTreeNode ret = new SegmentTreeNode(start, end);
            if (start == end) {
                ret.sum = nums[start];
            } else {
                int mid = start  + (end - start) / 2;             
                ret.left = buildTree(nums, start, mid);
                ret.right = buildTree(nums, mid + 1, end);
                ret.sum = ret.left.sum + ret.right.sum;
            }         
            return ret;
        }
    }
   
    void update(int i, int val) {
        update(root, i, val);
    }
   
    void update(SegmentTreeNode root, int pos, int val) {
        if (root.start == root.end) {
           root.sum = val;
        } else {
            int mid = root.start + (root.end - root.start) / 2;
            if (pos &lt;= mid) {
                 update(root.left, pos, val);
            } else {
                 update(root.right, pos, val);
            }
            root.sum = root.left.sum + root.right.sum;
        }
    }

    public int sumRange(int i, int j) {
        return sumRange(root, i, j);
    }
    
    public int sumRange(SegmentTreeNode root, int start, int end) {
        if (root.end == end &amp;&amp; root.start == start) {
            return root.sum;
        } else {
            int mid = root.start + (root.end - root.start) / 2;
            if (end &lt;= mid) {
                return sumRange(root.left, start, end);
            } else if (start &gt;= mid+1) {
                return sumRange(root.right, start, end);
            }  else {    
                return sumRange(root.right, mid+1, end) + sumRange(root.left, start, mid);
            }
        }
    }
}
</code></pre>
<p><strong>LFU</strong></p>
<p>Use three HashMap to save &lt;key, value&gt; pair, &lt;key, count&gt; pair and &lt;key, LinkedHashSet&gt; pair. LinkedHashSet keep track of keys of the same count.</p>
<pre><code>public class LFUCache {
    HashMap&lt;Integer, Integer&gt; vals;
    HashMap&lt;Integer, Integer&gt; counts;
    HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; lists;
    int cap;
    int min = -1;
    public LFUCache(int capacity) {
        cap = capacity;
        vals = new HashMap&lt;&gt;();
        counts = new HashMap&lt;&gt;();
        lists = new HashMap&lt;&gt;();
        lists.put(1, new LinkedHashSet&lt;&gt;());
    }
    
    public int get(int key) {
        if(!vals.containsKey(key))
            return -1;
        int count = counts.get(key);
        counts.put(key, count+1);
        lists.get(count).remove(key);
        if(count==min &amp;&amp; lists.get(count).size()==0)
            min++;
        if(!lists.containsKey(count+1))
            lists.put(count+1, new LinkedHashSet&lt;&gt;());
        lists.get(count+1).add(key);
        return vals.get(key);
    }
    
    public void put(int key, int value) {
        if(cap&lt;=0)
            return;
        if(vals.containsKey(key)) {
            vals.put(key, value);
            get(key);
            return;
        } 
        if(vals.size() &gt;= cap) {
            int evit = lists.get(min).iterator().next();
            lists.get(min).remove(evit);
            vals.remove(evit);
        }
        vals.put(key, value);
        counts.put(key, 1);
        min = 1;
        lists.get(1).add(key);
    }
}
</code></pre>
<p><strong>LRU</strong></p>
<p>Use HashMap to save &lt;key, Node&gt; pair. And create head, tail dummy double linked list node to keep track of recently used node queue.</p>
<pre><code>import java.util.Hashtable;
public class LRUCache {

  class DLinkedNode {
    int key;
    int value;
    DLinkedNode prev;
    DLinkedNode next;
  }

  private void addNode(DLinkedNode node) {
    /**
     * Always add the new node right after head.
     */
    node.prev = head;
    node.next = head.next;

    head.next.prev = node;
    head.next = node;
  }

  private void removeNode(DLinkedNode node){
    /**
     * Remove an existing node from the linked list.
     */
    DLinkedNode prev = node.prev;
    DLinkedNode next = node.next;

    prev.next = next;
    next.prev = prev;
  }

  private void moveToHead(DLinkedNode node){
    /**
     * Move certain node in between to the head.
     */
    removeNode(node);
    addNode(node);
  }

  private DLinkedNode popTail() {
    /**
     * Pop the current tail.
     */
    DLinkedNode res = tail.prev;
    removeNode(res);
    return res;
  }

  private Hashtable&lt;Integer, DLinkedNode&gt; cache =
          new Hashtable&lt;Integer, DLinkedNode&gt;();
  private int size;
  private int capacity;
  private DLinkedNode head, tail;

  public LRUCache(int capacity) {
    this.size = 0;
    this.capacity = capacity;

    head = new DLinkedNode();
    // head.prev = null;

    tail = new DLinkedNode();
    // tail.next = null;

    head.next = tail;
    tail.prev = head;
  }

  public int get(int key) {
    DLinkedNode node = cache.get(key);
    if (node == null) return -1;

    // move the accessed node to the head;
    moveToHead(node);

    return node.value;
  }

  public void put(int key, int value) {
    DLinkedNode node = cache.get(key);

    if(node == null) {
      DLinkedNode newNode = new DLinkedNode();
      newNode.key = key;
      newNode.value = value;

      cache.put(key, newNode);
      addNode(newNode);

      ++size;

      if(size &gt; capacity) {
        // pop the tail
        DLinkedNode tail = popTail();
        cache.remove(tail.key);
        --size;
      }
    } else {
      // update the value.
      node.value = value;
      moveToHead(node);
    }
  }
}
</code></pre>
<p><strong>LCM  lowest Common multiple and GCD greatest common denominator</strong></p>
<pre><code>// function to calculate gcd or  
// hcf of two numbers. 
static int gcd(int a, int b) 
{ 
		if (a == 0) 
				return b; 

		return gcd(b % a, a); 
} 

// function to calculate lcm of 
// two numbers. 
static int lcm(int a, int b) 
{ 
		return (a * b) / gcd(a, b); 
}  
</code></pre>
<p><strong>Dijkstra Algorithm</strong></p>
<p>Shortest distance
743. Network Delay Time
787. Cheapest Flights Within K Stops</p>
<pre><code>class Solution {
    public int networkDelayTime(int[][] times, int N, int K) {
        Map&lt;Integer, List&lt;int[]&gt;&gt; graph = new HashMap();
        for (int[] edge: times) {
            if (!graph.containsKey(edge[0]))
                graph.put(edge[0], new ArrayList&lt;int[]&gt;());
            graph.get(edge[0]).add(new int[]{edge[1], edge[2]});
        }
        PriorityQueue&lt;int[]&gt; heap = new PriorityQueue&lt;int[]&gt;(
                (info1, info2) -&gt; info1[0] - info2[0]);
        heap.offer(new int[]{0, K});

        Map&lt;Integer, Integer&gt; dist = new HashMap();

        while (!heap.isEmpty()) {
            int[] info = heap.poll();
            int d = info[0], node = info[1];
            if (dist.containsKey(node)) continue;
            dist.put(node, d);
            if (graph.containsKey(node))
                for (int[] edge: graph.get(node)) {
                    int nei = edge[0], d2 = edge[1];
                    if (!dist.containsKey(nei))
                        heap.offer(new int[]{d+d2, nei});
                }
        }

        if (dist.size() != N) return -1;
        int ans = 0;
        for (int cand: dist.values())
            ans = Math.max(ans, cand);
        return ans;
    }
}
</code></pre>
<p><strong>Generate Maze</strong></p>
<p>Because the wall has thickness of 1, DFS step size is 2.</p>
<pre><code>public int[][] maze(int n) {
	int[][] maze = new int[n][n];
	for (int i = 0; i &lt; n; i++) {
		for (int j = 0; j &lt; n; j++) {
			maze[i][j] = 1;
		}
	}
	maze[0][0] = 0;
	generate(maze, 0, 0);
	return maze;
}
private void generate(int[][] maze, int x, int y) {
	int[] dx = {0, 1, 0, -1};
	int[] dy = {1, 0, -1, 0};
	shuffle(dx, dy);
	for (int i = 0; i &lt; 4; i++) {
		if (x + dx[i] * 2 &gt;= 0 &amp;&amp; x + dx[i] * 2 &lt; maze.length &amp;&amp; y + dy[i] * 2 &gt;= 0 
			&amp;&amp; y + dy[i] * 2 &lt; maze[0].length &amp;&amp; maze[x + dx[i] * 2][y + dy[i] * 2] == 1) {
				maze[x + dx[i] * 2][y + dy[i] * 2] = 0;
				maze[x + dx[i]][y + dy[i]] = 0;
				generate(maze, x + dx[i] * 2, y + dy[i] * 2);
			}
	}
}
private void shuffle(int[] dx, int[] dy) {
	for (int i = 0; i &lt; dx.length - 1; i++) {
		int offset = (int) (Math.random() * (dx.length - i));
		int temp = dx[i];
		dx[i] = dx[i + offset];
		dx[i + offset] = temp;
		temp = dy[i];
		dy[i] = dy[i + offset];
		dy[i + offset] = temp;
	}
}
</code></pre>
<p><strong>Union Find</strong></p>
<pre><code>int count, n;
int[] f;
public int regionsBySlashes(String[] grid) {
		n = grid.length;
		f = new int[n * n * 4];
		count = n * n * 4;
		for (int i = 0; i &lt; n * n * 4; ++i)
				f[i] = i;
		for (int i = 0; i &lt; n; ++i) {
				for (int j = 0; j &lt; n; ++j) {
						if (i &gt; 0) union(g(i - 1, j, 2), g(i, j, 0));
						if (j &gt; 0) union(g(i , j - 1, 1), g(i , j, 3));
						if (grid[i].charAt(j) != '/') {
								union(g(i , j, 0), g(i , j,  1));
								union(g(i , j, 2), g(i , j,  3));
						}
						if (grid[i].charAt(j) != '\\') {
								union(g(i , j, 0), g(i , j,  3));
								union(g(i , j, 2), g(i , j,  1));
						}
				}
		}
		return count;
}

public int find(int x) {
		if (x != f[x]) {
				f[x] = find(f[x]);
		}
		return f[x];
}
public void union(int x, int y) {
		x = find(x); y = find(y);
		if (x != y) {
				f[x] = y;
				count--;
		}
}
public int g(int i, int j, int k) {
		return (i * n + j) * 4 + k;
}
</code></pre>
<p><strong>Reservoir Sampling</strong></p>
<ol>
<li>Create an array reservoir[0..k-1] and copy first k items of stream[] to it.</li>
<li>Now one by one consider all items from (k+1)th item to nth item.
…a) Generate a random number from 0 to i where i is index of current item in stream[]. Let the generated random number is j.
…b) If j is in range 0 to k-1, replace reservoir[j] with arr[i]</li>
</ol>
<pre><code>static void selectKItems(int stream[], int n, int k) 
{ 
		int i;   // index for elements in stream[] 

		// reservoir[] is the output array. Initialize it with 
		// first k elements from stream[] 
		int reservoir[] = new int[k]; 
		for (i = 0; i &lt; k; i++) 
				reservoir[i] = stream[i]; 

		Random r = new Random(); 

		// Iterate from the (k+1)th element to nth element 
		for (; i &lt; n; i++) 
		{ 
				// Pick a random index from 0 to i. 
				int j = r.nextInt(i + 1); 

				// If the randomly  picked index is smaller than k, 
				// then replace the element present at the index 
				// with new element from stream 
				if(j &lt; k) 
						reservoir[j] = stream[i];             
		} 

		System.out.println(&quot;Following are k randomly selected items&quot;); 
		System.out.println(Arrays.toString(reservoir)); 
} 
</code></pre>
<p><strong>315. Count of Smaller Numbers After Self</strong></p>
<p>When we try to insert a number, the total number of smaller number would be adding dup and sum of the nodes where we turn right.</p>
<pre><code>public class Solution {
    class Node {
        Node left, right;
        int val, sum;
				int dup = 1;  // count of same numbers
        public Node(int v, int s) {
            val = v;
            sum = s;
        }
    }
    public List&lt;Integer&gt; countSmaller(int[] nums) {
        Integer[] ans = new Integer[nums.length];
        Node root = null;
        for (int i = nums.length - 1; i &gt;= 0; i--) {
            root = insert(nums[i], root, ans, i, 0);
        }
        return Arrays.asList(ans);
    }
    private Node insert(int num, Node node, Integer[] ans, int i, int preSum) {
        if (node == null) {
            node = new Node(num, 0);
            ans[i] = preSum;
        } else if (node.val == num) {
            node.dup++;
            ans[i] = preSum + node.sum;
        } else if (node.val &gt; num) {
            node.sum++;
            node.left = insert(num, node.left, ans, i, preSum);
        } else {
            node.right = insert(num, node.right, ans, i, preSum + node.dup + node.sum);
        }
        return node;
    }
}
</code></pre>
<p><strong>406. Queue Reconstruction by Height</strong></p>
<p>Sort the (height, count of higher before self) by (descending, ascending). Insert by count of higher before.</p>
<pre><code>class Solution {
    public int[][] reconstructQueue(int[][] people) {
        if (people == null || people.length == 0 || people[0].length == 0)
            return new int[0][0];
            
        Arrays.sort(people, new Comparator&lt;int[]&gt;() {
            public int compare(int[] a, int[] b) {
                if (b[0] == a[0]) return a[1] - b[1];
                return b[0] - a[0];
            }
        });
        
        int n = people.length;
        ArrayList&lt;int[]&gt; tmp = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; n; i++)
            tmp.add(people[i][1], new int[]{people[i][0], people[i][1]});

        int[][] res = new int[people.length][2];
        int i = 0;
        for (int[] k : tmp) {
            res[i][0] = k[0];
            res[i++][1] = k[1];
        }
        
        return res;
    }
}
</code></pre>
<p><strong>1027. Longest Arithmetic Sequence</strong></p>
<pre><code>public int longestArithSeqLength(int[] A) {
		int res = 2, n = A.length;
		HashMap&lt;Integer, Integer&gt;[] dp = new HashMap[n];
		for (int j = 0; j &lt; A.length; j++) {
				dp[j] = new HashMap&lt;&gt;();
				for (int i = 0; i &lt; j; i++) {
						int d = A[j] - A[i];
						dp[j].put(d, dp[i].getOrDefault(d, 1) + 1);
						res = Math.max(res, dp[j].get(d));
				}
		}
		return res;
}
</code></pre>
<p><strong>Decreasing Subsequences</strong></p>
<p>The number of decreasing subsequence partitions is equal to the length of the longest non-decreasing subsequence.</p>
<pre><code>public static int leastSubsequences(int... nums) {
		int[] piles = new int[nums.length];
		int size = 0;
		for (int val : nums) {
				int pile = binarySearch(piles, 0, size, val);
				piles[pile] = val;
				if (pile == size) size++;
		 }
		return size;
}

// find first element greater than target
public static int binarySearch(int[] nums, int lo, int hi, int target) {
		while (lo &lt; hi) {
				int mid = (lo + hi) &gt;&gt;&gt; 1;
				if (nums[mid] &lt;= target) {
						lo = mid + 1;
				} else {
						hi = mid;
				}
		}
		return lo;
}
</code></pre>
<p><strong>683. K Empty Slots</strong></p>
<pre><code>public int kEmptySlots(int[] flowers, int k) {
    TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;();
        
    for (int i = 0; i &lt; flowers.length; i++) {
        int xc = flowers[i], xl = xc - (k + 1), xr = xc + (k + 1);
            
        Integer l = set.lower(xc);
        if (l != null &amp;&amp; l == xl) return i + 1;
        
        Integer r = set.higher(xc);
        if (r != null &amp;&amp; r == xr) return i + 1;
        
        set.add(xc);
    }
    
    return -1;
}
</code></pre>
<p>**Kruskal's Minimum Spanning Tree **</p>
<ol>
<li>Sort all the edges in non-decreasing order of their weight.</li>
<li>Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If cycle is not formed, include this edge. Else, discard it.</li>
<li>Repeat step#2 until there are (V-1) edges in the spanning tree.</li>
</ol>
<pre><code>
// The main function to construct MST using Kruskal's algorithm 
void KruskalMST() 
{ 
		Edge result[] = new Edge[V];  // Tnis will store the resultant MST 
		int e = 0;  // An index variable, used for result[] 
		int i = 0;  // An index variable, used for sorted edges 
		for (i=0; i&lt;V; ++i) 
				result[i] = new Edge(); 

		// Step 1:  Sort all the edges in non-decreasing order of their 
		// weight.  If we are not allowed to change the given graph, we 
		// can create a copy of array of edges 
		Arrays.sort(edge); 

		// Allocate memory for creating V ssubsets 
		subset subsets[] = new subset[V]; 
		for(i=0; i&lt;V; ++i) 
				subsets[i]=new subset(); 

		// Create V subsets with single elements 
		for (int v = 0; v &lt; V; ++v) 
		{ 
				subsets[v].parent = v; 
				subsets[v].rank = 0; 
		} 

		i = 0;  // Index used to pick next edge 

		// Number of edges to be taken is equal to V-1 
		while (e &lt; V - 1) 
		{ 
				// Step 2: Pick the smallest edge. And increment  
				// the index for next iteration 
				Edge next_edge = new Edge(); 
				next_edge = edge[i++]; 

				int x = find(subsets, next_edge.src); 
				int y = find(subsets, next_edge.dest); 

				// If including this edge does't cause cycle, 
				// include it in result and increment the index  
				// of result for next edge 
				if (x != y) 
				{ 
						result[e++] = next_edge; 
						Union(subsets, x, y); 
				} 
				// Else discard the next_edge 
		} 

		// print the contents of result[] to display 
		// the built MST 
		System.out.println(&quot;Following are the edges in &quot; +  
																 &quot;the constructed MST&quot;); 
		for (i = 0; i &lt; e; ++i) 
				System.out.println(result[i].src+&quot; -- &quot; +  
							 result[i].dest+&quot; == &quot; + result[i].weight); 
} 
</code></pre>
<p><strong>smallest positive number missing</strong></p>
<pre><code>static int findMissingNo(int []arr, int n) 
	{ 
			// to store current array element 
			int val; 

			// to store next array element in 
			// current traversal 
			int nextval; 

			for (int i = 0; i &lt; n; i++) { 

					// if value is negative or greater 
					// than array size, then it cannot 
					// be marked in array. So move to 
					// next element. 
					if (arr[i] &lt;= 0 || arr[i] &gt; n) 
							continue; 

					val = arr[i]; 

					// traverse the array until we 
					// reach at an element which 
					// is already marked or which 
					// could not be marked. 
					while (arr[val - 1] != val) { 
							nextval = arr[val - 1]; 
							arr[val - 1] = val; 
							val = nextval; 
							if (val &lt;= 0 || val &gt; n) 
									break; 
					} 
			} 

			// find first array index which is 
			// not marked which is also the 
			// smallest positive missing 
			// number. 
			for (int i = 0; i &lt; n; i++) { 
					if (arr[i] != i + 1) { 
							return i + 1; 
					} 
			} 

			// if all indices are marked, then 
			// smallest missing positive 
			// number is array_size + 1. 
			return n + 1; 
	} 
</code></pre>
<p>**642. Design Search Autocomplete System -Trie **</p>
<pre><code>class AutocompleteSystem {
    
    class TrieNode {
        public Map&lt;Character, TrieNode&gt; children;
        public Map&lt;String, Integer&gt; count;
        
        public TrieNode() {
            children = new HashMap&lt;&gt;();
            count = new HashMap&lt;&gt;();
        }
    }

    TrieNode root;
    
    public AutocompleteSystem(String[] sentences, int[] times) {
        root = new TrieNode();
        for (int i = 0; i &lt; sentences.length; i++) { 
            addSentence(sentences[i], times[i]);
        }
    }
    
    public void addSentence(String s, int count) {
        char[] cs = s.toCharArray();
        TrieNode cur = root;
        for (int j = 0; j &lt; cs.length; j++) {
            cur.children.putIfAbsent(cs[j], new TrieNode());
            cur = cur.children.get(cs[j]);
            cur.count.put(s, cur.count.getOrDefault(s, 0) + count);
        }
    }
    
    String prev = &quot;&quot;; 
    
    public List&lt;String&gt; input(char c) {
        if (c == '#') {
            addSentence(prev, 1);
            prev = &quot;&quot;;  
            return new ArrayList&lt;&gt;();
        } 
        prev += c;
        TrieNode curr = root;
        
        for (char cc : prev.toCharArray()) {
            TrieNode next = curr.children.get(cc);
            if (next == null) {
                return new ArrayList&lt;String&gt;();
            }
            curr = next;
        }
        
        PriorityQueue&lt;Map.Entry&lt;String, Integer&gt;&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; {
            if (a.getValue() != b.getValue()) {
                return Integer.compare(b.getValue(), a.getValue());
            }
            else {
                return a.getKey().compareTo(b.getKey());
            }
        });
        
        for (Map.Entry&lt;String, Integer&gt; e : curr.count.entrySet()) {
            pq.add(e);
        }
        
        List&lt;String&gt; res = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 3 &amp;&amp; !pq.isEmpty(); i++) {
            res.add(pq.poll().getKey());
        }
        
        return res;
    }
}
</code></pre>
<p><strong>34. Find First and Last Position of Element in Sorted Array</strong></p>
<pre><code>class Solution {
    public int[] searchRange(int[] nums, int target) {
        
        int[] targetRange = {-1, -1};
        if (nums == null || nums.length &lt; 1) {
            return targetRange;
        }
        int leftIdx = findLeft(nums, target);
        if (nums[leftIdx] != target) {
            return targetRange;
        }

        targetRange[0] = leftIdx;
        targetRange[1] = findRight(nums, target)-1;

        return targetRange;
    }
    
    private int findLeft(int[] nums, int target) {
        int lo = 0;
        int hi = nums.length - 1;

        while (lo &lt; hi) {
            int mid = (lo + hi) / 2;
            if (nums[mid] &gt;= target) {
                hi = mid;
            }
            else {
                lo = mid+1;
            }
        }
        return lo;
    }
    
    private int findRight(int[] nums, int target) {
        int lo = 0;
        int hi = nums.length - 1;

        while (lo &lt;= hi) {
            int mid = (lo + hi) / 2;
            if (nums[mid] &gt; target) {
                hi = mid - 1;
            }
            else {
                lo = mid+1;
            }
        }
        return lo;
    }   
}
</code></pre>
<p><strong>421. Maximum XOR of Two Numbers in an Array</strong></p>
<pre><code> public int findMaximumXOR(int[] nums) {
        int maxResult = 0; 
        int mask = 0;
        /*The maxResult is a record of the largest XOR we got so far. if it's 11100 at i = 2, it means 
        before we reach the last two bits, 11100 is the biggest XOR we have, and we're going to explore
        whether we can get another two '1's and put them into maxResult
        
        This is a greedy part, since we're looking for the largest XOR, we start 
        from the very begining, aka, the 31st postition of bits. */
        for (int i = 31; i &gt;= 0; i--) {
            
            //The mask will grow like  100..000 , 110..000, 111..000,  then 1111...111
            //for each iteration, we only care about the left parts
            mask = mask | (1 &lt;&lt; i);
            
            Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
            for (int num : nums) {
                
/*                we only care about the left parts, for example, if i = 2, then we have
                {1100, 1000, 0100, 0000} from {1110, 1011, 0111, 0010}*/
                int leftPartOfNum = num &amp; mask;
                set.add(leftPartOfNum);
            }
            
            // if i = 1 and before this iteration, the maxResult we have now is 1100, 
            // my wish is the maxResult will grow to 1110, so I will try to find a candidate
            // which can give me the greedyTry;
            int greedyTry = maxResult | (1 &lt;&lt; i);
            
            for (int leftPartOfNum : set) {
                //This is the most tricky part, coming from a fact that if a ^ b = c, then a ^ c = b;
                // now we have the 'c', which is greedyTry, and we have the 'a', which is leftPartOfNum
                // If we hope the formula a ^ b = c to be valid, then we need the b, 
                // and to get b, we need a ^ c, if a ^ c exisited in our set, then we're good to go
                int anotherNum = leftPartOfNum ^ greedyTry;
                if (set.contains(anotherNum)) {
                    maxResult= greedyTry;
                    break;
                }
            }
            
            // If unfortunately, we didn't get the greedyTry, we still have our max, 
            // So after this iteration, the max will stay at 1100.
        }
        
        return maxResult;
    }
</code></pre>
<p><strong>685. Redundant Connection II</strong></p>
<p>directed graph</p>
<p>any edge in circle
<img src="https://ywang412.github.io/post-images/1568823506044.png" alt=""></p>
<p>the one of the two indegree edges in circle
<img src="https://ywang412.github.io/post-images/1568823510240.png" alt=""></p>
<p>either on of the two indegree edges in circle
<img src="https://ywang412.github.io/post-images/1568823514153.png" alt=""></p>
<pre><code>class Solution {
    public int[] findRedundantDirectedConnection(int[][] edges) {
        int[] can1 = {-1, -1};
        int[] can2 = {-1, -1};
        int[] parent = new int[edges.length + 1];
        for (int i = 0; i &lt; edges.length; i++) {
            if (parent[edges[i][1]] == 0) {
                parent[edges[i][1]] = edges[i][0];
            } else {
                can2 = new int[] {edges[i][0], edges[i][1]};
                can1 = new int[] {parent[edges[i][1]], edges[i][1]};
                edges[i][1] = 0;
            }
        }
        for (int i = 0; i &lt; edges.length; i++) {
            parent[i] = i;
        }
        for (int i = 0; i &lt; edges.length; i++) {
            if (edges[i][1] == 0) {
                continue;
            }
            int child = edges[i][1], father = edges[i][0];
            if (root(parent, father) == child) {
                if (can1[0] == -1) {
                    return edges[i];
                }
                return can1;
            }
            parent[child] = father;
        }
        return can2;
    }
    
    int root(int[] parent, int i) {
        while (i != parent[i]) {
            parent[i] = parent[parent[i]];
            i = parent[i];
        }   
        return i;
    }
}
</code></pre>
<p><strong>1096. Brace Expansion II</strong></p>
<pre><code>public List&lt;String&gt; braceExpansionII(String expression) {
		 String s = expression;
		 char preSign = ',';
		 Stack&lt;List&lt;String&gt;&gt; stack = new Stack&lt;&gt;();// Save List&lt;String&gt;
		 for (int i = 0; i &lt; s.length(); i++){
				 char c = s.charAt(i);
				 // case 1. {...} recursive, stack.operate(resList) by preSign
				 if (c == '{'){
						 int j = i, p = 1;
						 while (s.charAt(j) != '}' || p != 0){
								 j++;
								 if (s.charAt(j) == '{') p++;
								 if (s.charAt(j) == '}') p--;
						 }
						 List&lt;String&gt; slist = braceExpansionII(s.substring(i+1, j));
						 if (preSign == '*'){
								 stack.push(merge(stack.pop(), slist));
						 }
						 else stack.push(slist);
						 i = j;
			//default preSign is *
						 preSign = '*';
				 }
				 // case 2 letter operate by preSign
				 else if (Character.isLetter(c)){
						 List&lt;String&gt; slist = new ArrayList&lt;&gt;();
						 slist.add(&quot;&quot;+c);
               if (preSign == '*'){
                   stack.push(merge(stack.pop(), slist));
               }
               else stack.push(slist);
   			// //default preSign is *
               preSign = '*';
           }
           // case 3. if  == &quot;, &quot;, preSign is  plus, (default preSign is *);
           if (c ==',' || i == s.length()-1){
               preSign = ',';
           }
       }
       // output stack to one dimesion list;
       List&lt;String&gt; res = new ArrayList&lt;&gt;();
       while(!stack.isEmpty()){
           for (String l : stack.pop())
               if (!res.contains(l))res.add(l);
       }
   	// sort by lexi-order
       Collections.sort(res);
       return res;
   }
   // multiply operation of 2 List&lt;letter&gt;
   public List&lt;String&gt; merge(List&lt;String&gt; list1, List&lt;String&gt; list2){
       List&lt;String&gt; res = new ArrayList&lt;&gt;();
       for (String l1 : list1){
           for (String l2 : list2){
               res.add(l1+l2);
           }
       }
       return res;
   }
</code></pre>
<p><strong>Detect cycle in undirected gragh</strong></p>
<pre><code>// A recursive function that uses visited[] and parent to detect 
// cycle in subgraph reachable from vertex v. 
Boolean isCyclicUtil(int v, Boolean visited[], int parent) 
{ 
		// Mark the current node as visited 
		visited[v] = true; 
		Integer i; 

		// Recur for all the vertices adjacent to this vertex 
		Iterator&lt;Integer&gt; it = adj[v].iterator(); 
		while (it.hasNext()) 
		{ 
				i = it.next(); 

				// If an adjacent is not visited, then recur for that 
				// adjacent 
				if (!visited[i]) 
				{ 
						if (isCyclicUtil(i, visited, v)) 
								return true; 
				} 

				// If an adjacent is visited and not parent of current 
				// vertex, then there is a cycle. 
				else if (i != parent) 
						return true; 
		} 
		return false; 
} 

// Returns true if the graph contains a cycle, else false. 
Boolean isCyclic() 
{ 
		// Mark all the vertices as not visited and not part of 
		// recursion stack 
		Boolean visited[] = new Boolean[V]; 
		for (int i = 0; i &lt; V; i++) 
				visited[i] = false; 

		// Call the recursive helper function to detect cycle in 
		// different DFS trees 
		for (int u = 0; u &lt; V; u++) 
				if (!visited[u]) // Don't recur for u if already visited 
						if (isCyclicUtil(u, visited, -1)) 
								return true; 

		return false; 
} 
</code></pre>
<p><strong>943. Find the Shortest Superstring</strong></p>
<p>Travelling salesman problem</p>
<pre><code>class Solution {
    public String shortestSuperstring(String[] A) {
        int n = A.length;
        int[][] graph = new int[n][n];
        // build the graph
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                graph[i][j] = calc(A[i], A[j]);
                graph[j][i] = calc(A[j], A[i]);
            }
        }
        int[][] dp = new int[1 &lt;&lt; n][n];
        int[][] path = new int[1 &lt;&lt; n][n];
        int last = -1, min = Integer.MAX_VALUE;
		
        // start TSP DP
        for (int i = 1; i &lt; (1 &lt;&lt; n); i++) {
            Arrays.fill(dp[i], Integer.MAX_VALUE);
            for (int j = 0; j &lt; n; j++) {
                if ((i &amp; (1 &lt;&lt; j)) &gt; 0) {
                    int prev = i - (1 &lt;&lt; j);
                    if (prev == 0) {
                        dp[i][j] = A[j].length();
                    } else {
                        for (int k = 0; k &lt; n; k++) {
                            if (dp[prev][k] &lt; Integer.MAX_VALUE &amp;&amp; dp[prev][k] + graph[k][j] &lt; dp[i][j]) {
                                dp[i][j] = dp[prev][k] + graph[k][j];
                                path[i][j] = k;
                            }
                        }
                    }
                }
                if (i == (1 &lt;&lt; n) - 1 &amp;&amp; dp[i][j] &lt; min) {
                    min = dp[i][j];
                    last = j;
                }
            }
        }
		
        // build the path
        StringBuilder sb = new StringBuilder();
        int cur = (1 &lt;&lt; n) - 1;
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        while (cur &gt; 0) {
            stack.push(last);
            int temp = cur;
            cur -= (1 &lt;&lt; last);
            last = path[temp][last];
        }
		
        // build the result
        int i = stack.pop();
        sb.append(A[i]);
        while (!stack.isEmpty()) {
            int j = stack.pop();
            sb.append(A[j].substring(A[j].length() - graph[i][j]));
            i = j;
        }
        return sb.toString();
    }
    private int calc(String a, String b) {
        for (int i = 1; i &lt; a.length(); i++) {
            if (b.startsWith(a.substring(i))) {
                return b.length() - a.length() + i;
            }
        }
        return b.length();
    }
}
</code></pre>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://ywang412.github.io/tag/fy8llECIr" class="tag">
                    LeetCode
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://ywang412.github.io/post/resume">
                  <h3 class="post-title">
                    Resume
                  </h3>
                </a>
              </div>
            

            
              

              
                <div id="disqus_thread" data-aos="fade-in"></div>
              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  

  
    <script src="https://unpkg.com/disqusjs@1.1/dist/disqus.js"></script>
    <script>

    var options = {
      shortname: 'ywang412',
      apikey: 'gmr5wORrpUmczJ0fs6x1CjNX2WgIP2riU2sSqLrIo6Idh3GkyiY8WIpUwBaP70X5',
    }
    if ('') {
      options.api = ''
    }
    var dsqjs = new DisqusJS(options)

    </script>
  




  </body>
</html>
