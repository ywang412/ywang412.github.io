<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Non-trival textbook algorithms | Yu&#39;s Github</title>
<meta name="description" content="Java by day, Scala by night">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://ywang412.github.io/favicon.ico?v=1567742779312">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://ywang412.github.io/styles/main.css">


  

  
    <link rel="stylesheet" href="https://unpkg.com/disqusjs@1.1/dist/disqusjs.css" />
  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-143424668-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-143424668-1');
</script>


  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://ywang412.github.io">
        <img src="https://ywang412.github.io/images/avatar.png?v=1567742779312" class="site-logo">
        <h1 class="site-title">Yu&#39;s Github</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            Home
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            Archive
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            Tag
          </a>
        
      
        
          <a href="/post/resume" class="site-nav">
            Resume
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/ywang412/" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      Java by day, Scala by night
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://ywang412.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">Non-trival textbook algorithms</h2>
            <div class="post-date">2018-04-06</div>
            
            <div class="post-content">
              <p><strong>229. Majority Element II  - Moore's Voting Algorithm</strong></p>
<p>The trick in Moore voting algorithm is to aggregate the top n more frequent elements when counting. If the element in iteration is not equal to any of the top n elements, the counts of each top n elements will decrease by one. Moreover, top n elements are different as a result of the initialization order.</p>
<pre><code>int first = nums[0];
int c1 = 1;
int second = Integer.MIN_VALUE;
int c2 = 0;

for (int i = 1; i &lt; nums.length; i++) {
		if (nums[i] == first) c1++;
		else if (nums[i] == second) c2++;
		else if (c1 == 0) {
						first = nums[i];
						c1 = 1;
		}
		else if (c2 == 0) {
						second = nums[i];
						c2 = 1;
				}
		else {
				c1--;
				c2--;
		}
}
</code></pre>
<p><strong>973. K Closest Points to Origin - quick find</strong></p>
<p>To find the kth smallest element, Arrays.sort() will take Nlog(N). Min priority queue can reduce it to Nlog(k). However, if we don't care about the order of the K closest points, quick find can return it in O(N) average time and O(N*N) worst time.</p>
<pre><code>public int[][] kClosest(int[][] points, int K) {
    int len =  points.length, l = 0, r = len - 1;
    while (l &lt;= r) {
        int mid = helper(points, l, r);
        if (mid == K) break;
        if (mid &lt; K) {
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    return Arrays.copyOfRange(points, 0, K);
}

private int helper(int[][] A, int l, int r) {
    int[] pivot = A[l];
    while (l &lt; r) {
        while (l &lt; r &amp;&amp; compare(A[r], pivot) &gt;= 0) r--;
        A[l] = A[r];
        while (l &lt; r &amp;&amp; compare(A[l], pivot) &lt;= 0) l++;
        A[r] = A[l];
    }
    A[l] = pivot;
    return l;
}

private int compare(int[] p1, int[] p2) {
    return p1[0] * p1[0] + p1[1] * p1[1] - p2[0] * p2[0] - p2[1] * p2[1];
}
</code></pre>
<p><strong>Morris traversal</strong></p>
<p>Inorder morris traversal will visit root node right before reverting the right child change.</p>
<pre><code>class BinaryTree { 
    tNode root; 
  
    /* Function to traverse a binary tree without recursion and  
       without stack */
    void MorrisTraversal(tNode root) 
    { 
        tNode current, pre; 
  
        if (root == null) 
            return; 
  
        current = root; 
        while (current != null) { 
            if (current.left == null) { 
                System.out.print(current.data + &quot; &quot;); 
                current = current.right; 
            } 
            else { 
                /* Find the inorder predecessor of current */
                pre = current.left; 
                while (pre.right != null &amp;&amp; pre.right != current) 
                    pre = pre.right; 
  
                /* Make current as right child of its inorder predecessor */
                if (pre.right == null) { 
                    pre.right = current; 
                    current = current.left; 
                } 
  
                /* Revert the changes made in the 'if' part to restore the  
                    original tree i.e., fix the right child of predecessor*/
                else { 
                    pre.right = null; 
                    System.out.print(current.data + &quot; &quot;); 
                    current = current.right; 
                } /* End of if condition pre-&gt;right == NULL */
  
            } /* End of if condition current-&gt;left == NULL*/
  
        } /* End of while */
    } 
}
</code></pre>
<p>Pre-order morris traversal will visit root node during right before the right child change.</p>
<pre><code>class BinaryTree { 
      
    Node root; 
      
    void morrisTraversalPreorder() 
    { 
        morrisTraversalPreorder(root); 
    } 
  
    // Preorder traversal without recursion and without stack 
    void morrisTraversalPreorder(Node node) { 
        while (node != null) { 
  
            // If left child is null, print the current node data. Move to 
            // right child. 
            if (node.left == null) { 
                System.out.print(node.data + &quot; &quot;); 
                node = node.right; 
            } else { 
  
                // Find inorder predecessor 
                Node current = node.left; 
                while (current.right != null &amp;&amp; current.right != node) { 
                    current = current.right; 
                } 
  
                // If the right child of inorder predecessor  
                // already points to this node 
                if (current.right == node) { 
                    current.right = null; 
                    node = node.right; 
                } 
   
                // If right child doesn't point to this node, then print 
                // this node and make right child point to this node 
                else { 
                    System.out.print(node.data + &quot; &quot;); 
                    current.right = node; 
                    node = node.left; 
                } 
            } 
        } 
    } 
}
</code></pre>
<p><strong>Segment Tree</strong></p>
<p>Representation of Segment trees</p>
<ol>
<li>Leaf Nodes are the elements of the input array.</li>
<li>Each internal node represents some merging of the leaf nodes. The merging may be different for different problems.</li>
</ol>
<pre><code>public class NumArray {

    class SegmentTreeNode {
        int start, end;
        SegmentTreeNode left, right;
        int sum;

        public SegmentTreeNode(int start, int end) {
            this.start = start;
            this.end = end;
            this.left = null;
            this.right = null;
            this.sum = 0;
        }
    }
      
    SegmentTreeNode root = null;
   
    public NumArray(int[] nums) {
        root = buildTree(nums, 0, nums.length-1);
    }

    private SegmentTreeNode buildTree(int[] nums, int start, int end) {
        if (start &gt; end) {
            return null;
        } else {
            SegmentTreeNode ret = new SegmentTreeNode(start, end);
            if (start == end) {
                ret.sum = nums[start];
            } else {
                int mid = start  + (end - start) / 2;             
                ret.left = buildTree(nums, start, mid);
                ret.right = buildTree(nums, mid + 1, end);
                ret.sum = ret.left.sum + ret.right.sum;
            }         
            return ret;
        }
    }
   
    void update(int i, int val) {
        update(root, i, val);
    }
   
    void update(SegmentTreeNode root, int pos, int val) {
        if (root.start == root.end) {
           root.sum = val;
        } else {
            int mid = root.start + (root.end - root.start) / 2;
            if (pos &lt;= mid) {
                 update(root.left, pos, val);
            } else {
                 update(root.right, pos, val);
            }
            root.sum = root.left.sum + root.right.sum;
        }
    }

    public int sumRange(int i, int j) {
        return sumRange(root, i, j);
    }
    
    public int sumRange(SegmentTreeNode root, int start, int end) {
        if (root.end == end &amp;&amp; root.start == start) {
            return root.sum;
        } else {
            int mid = root.start + (root.end - root.start) / 2;
            if (end &lt;= mid) {
                return sumRange(root.left, start, end);
            } else if (start &gt;= mid+1) {
                return sumRange(root.right, start, end);
            }  else {    
                return sumRange(root.right, mid+1, end) + sumRange(root.left, start, mid);
            }
        }
    }
}
</code></pre>
<p><strong>LFU</strong></p>
<p>Use three HashMap to save &lt;key, value&gt; pair, &lt;key, count&gt; pair and &lt;key, LinkedHashSet&gt; pair. LinkedHashSet keep track of keys of the same count.</p>
<pre><code>public class LFUCache {
    HashMap&lt;Integer, Integer&gt; vals;
    HashMap&lt;Integer, Integer&gt; counts;
    HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; lists;
    int cap;
    int min = -1;
    public LFUCache(int capacity) {
        cap = capacity;
        vals = new HashMap&lt;&gt;();
        counts = new HashMap&lt;&gt;();
        lists = new HashMap&lt;&gt;();
        lists.put(1, new LinkedHashSet&lt;&gt;());
    }
    
    public int get(int key) {
        if(!vals.containsKey(key))
            return -1;
        int count = counts.get(key);
        counts.put(key, count+1);
        lists.get(count).remove(key);
        if(count==min &amp;&amp; lists.get(count).size()==0)
            min++;
        if(!lists.containsKey(count+1))
            lists.put(count+1, new LinkedHashSet&lt;&gt;());
        lists.get(count+1).add(key);
        return vals.get(key);
    }
    
    public void put(int key, int value) {
        if(cap&lt;=0)
            return;
        if(vals.containsKey(key)) {
            vals.put(key, value);
            get(key);
            return;
        } 
        if(vals.size() &gt;= cap) {
            int evit = lists.get(min).iterator().next();
            lists.get(min).remove(evit);
            vals.remove(evit);
        }
        vals.put(key, value);
        counts.put(key, 1);
        min = 1;
        lists.get(1).add(key);
    }
}
</code></pre>
<p><strong>LRU</strong></p>
<p>Use HashMap to save &lt;key, Node&gt; pair. And create head, tail dummy double linked list node to keep track of recently used node queue.</p>
<pre><code>import java.util.Hashtable;
public class LRUCache {

  class DLinkedNode {
    int key;
    int value;
    DLinkedNode prev;
    DLinkedNode next;
  }

  private void addNode(DLinkedNode node) {
    /**
     * Always add the new node right after head.
     */
    node.prev = head;
    node.next = head.next;

    head.next.prev = node;
    head.next = node;
  }

  private void removeNode(DLinkedNode node){
    /**
     * Remove an existing node from the linked list.
     */
    DLinkedNode prev = node.prev;
    DLinkedNode next = node.next;

    prev.next = next;
    next.prev = prev;
  }

  private void moveToHead(DLinkedNode node){
    /**
     * Move certain node in between to the head.
     */
    removeNode(node);
    addNode(node);
  }

  private DLinkedNode popTail() {
    /**
     * Pop the current tail.
     */
    DLinkedNode res = tail.prev;
    removeNode(res);
    return res;
  }

  private Hashtable&lt;Integer, DLinkedNode&gt; cache =
          new Hashtable&lt;Integer, DLinkedNode&gt;();
  private int size;
  private int capacity;
  private DLinkedNode head, tail;

  public LRUCache(int capacity) {
    this.size = 0;
    this.capacity = capacity;

    head = new DLinkedNode();
    // head.prev = null;

    tail = new DLinkedNode();
    // tail.next = null;

    head.next = tail;
    tail.prev = head;
  }

  public int get(int key) {
    DLinkedNode node = cache.get(key);
    if (node == null) return -1;

    // move the accessed node to the head;
    moveToHead(node);

    return node.value;
  }

  public void put(int key, int value) {
    DLinkedNode node = cache.get(key);

    if(node == null) {
      DLinkedNode newNode = new DLinkedNode();
      newNode.key = key;
      newNode.value = value;

      cache.put(key, newNode);
      addNode(newNode);

      ++size;

      if(size &gt; capacity) {
        // pop the tail
        DLinkedNode tail = popTail();
        cache.remove(tail.key);
        --size;
      }
    } else {
      // update the value.
      node.value = value;
      moveToHead(node);
    }
  }
}
</code></pre>
<p><strong>LCM  lowest Common multiple and GCD greatest common denominator</strong></p>
<pre><code>// function to calculate gcd or  
// hcf of two numbers. 
static int gcd(int a, int b) 
{ 
		if (a == 0) 
				return b; 

		return gcd(b % a, a); 
} 

// function to calculate lcm of 
// two numbers. 
static int lcm(int a, int b) 
{ 
		return (a * b) / gcd(a, b); 
}  
</code></pre>
<p><strong>Dijkstra Algorithm</strong></p>
<p>Shortest distance
743. Network Delay Time
787. Cheapest Flights Within K Stops</p>
<pre><code>class Solution {
    public int networkDelayTime(int[][] times, int N, int K) {
        Map&lt;Integer, List&lt;int[]&gt;&gt; graph = new HashMap();
        for (int[] edge: times) {
            if (!graph.containsKey(edge[0]))
                graph.put(edge[0], new ArrayList&lt;int[]&gt;());
            graph.get(edge[0]).add(new int[]{edge[1], edge[2]});
        }
        PriorityQueue&lt;int[]&gt; heap = new PriorityQueue&lt;int[]&gt;(
                (info1, info2) -&gt; info1[0] - info2[0]);
        heap.offer(new int[]{0, K});

        Map&lt;Integer, Integer&gt; dist = new HashMap();

        while (!heap.isEmpty()) {
            int[] info = heap.poll();
            int d = info[0], node = info[1];
            if (dist.containsKey(node)) continue;
            dist.put(node, d);
            if (graph.containsKey(node))
                for (int[] edge: graph.get(node)) {
                    int nei = edge[0], d2 = edge[1];
                    if (!dist.containsKey(nei))
                        heap.offer(new int[]{d+d2, nei});
                }
        }

        if (dist.size() != N) return -1;
        int ans = 0;
        for (int cand: dist.values())
            ans = Math.max(ans, cand);
        return ans;
    }
}
</code></pre>
<p><strong>Generate Maze</strong></p>
<p>Because the wall has thickness of 1, DFS step size is 2.</p>
<pre><code>public int[][] maze(int n) {
	int[][] maze = new int[n][n];
	for (int i = 0; i &lt; n; i++) {
		for (int j = 0; j &lt; n; j++) {
			maze[i][j] = 1;
		}
	}
	maze[0][0] = 0;
	generate(maze, 0, 0);
	return maze;
}
private void generate(int[][] maze, int x, int y) {
	int[] dx = {0, 1, 0, -1};
	int[] dy = {1, 0, -1, 0};
	shuffle(dx, dy);
	for (int i = 0; i &lt; 4; i++) {
		if (x + dx[i] * 2 &gt;= 0 &amp;&amp; x + dx[i] * 2 &lt; maze.length &amp;&amp; y + dy[i] * 2 &gt;= 0 
			&amp;&amp; y + dy[i] * 2 &lt; maze[0].length &amp;&amp; maze[x + dx[i] * 2][y + dy[i] * 2] == 1) {
				maze[x + dx[i] * 2][y + dy[i] * 2] = 0;
				maze[x + dx[i]][y + dy[i]] = 0;
				generate(maze, x + dx[i] * 2, y + dy[i] * 2);
			}
	}
}
private void shuffle(int[] dx, int[] dy) {
	for (int i = 0; i &lt; dx.length - 1; i++) {
		int offset = (int) (Math.random() * (dx.length - i));
		int temp = dx[i];
		dx[i] = dx[i + offset];
		dx[i + offset] = temp;
		temp = dy[i];
		dy[i] = dy[i + offset];
		dy[i + offset] = temp;
	}
}
</code></pre>
<p><strong>Union Find</strong></p>
<pre><code>int count, n;
int[] f;
public int regionsBySlashes(String[] grid) {
		n = grid.length;
		f = new int[n * n * 4];
		count = n * n * 4;
		for (int i = 0; i &lt; n * n * 4; ++i)
				f[i] = i;
		for (int i = 0; i &lt; n; ++i) {
				for (int j = 0; j &lt; n; ++j) {
						if (i &gt; 0) union(g(i - 1, j, 2), g(i, j, 0));
						if (j &gt; 0) union(g(i , j - 1, 1), g(i , j, 3));
						if (grid[i].charAt(j) != '/') {
								union(g(i , j, 0), g(i , j,  1));
								union(g(i , j, 2), g(i , j,  3));
						}
						if (grid[i].charAt(j) != '\\') {
								union(g(i , j, 0), g(i , j,  3));
								union(g(i , j, 2), g(i , j,  1));
						}
				}
		}
		return count;
}

public int find(int x) {
		if (x != f[x]) {
				f[x] = find(f[x]);
		}
		return f[x];
}
public void union(int x, int y) {
		x = find(x); y = find(y);
		if (x != y) {
				f[x] = y;
				count--;
		}
}
public int g(int i, int j, int k) {
		return (i * n + j) * 4 + k;
}
</code></pre>
<p><strong>Reservoir Sampling</strong></p>
<ol>
<li>Create an array reservoir[0..k-1] and copy first k items of stream[] to it.</li>
<li>Now one by one consider all items from (k+1)th item to nth item.
…a) Generate a random number from 0 to i where i is index of current item in stream[]. Let the generated random number is j.
…b) If j is in range 0 to k-1, replace reservoir[j] with arr[i]</li>
</ol>
<pre><code>static void selectKItems(int stream[], int n, int k) 
{ 
		int i;   // index for elements in stream[] 

		// reservoir[] is the output array. Initialize it with 
		// first k elements from stream[] 
		int reservoir[] = new int[k]; 
		for (i = 0; i &lt; k; i++) 
				reservoir[i] = stream[i]; 

		Random r = new Random(); 

		// Iterate from the (k+1)th element to nth element 
		for (; i &lt; n; i++) 
		{ 
				// Pick a random index from 0 to i. 
				int j = r.nextInt(i + 1); 

				// If the randomly  picked index is smaller than k, 
				// then replace the element present at the index 
				// with new element from stream 
				if(j &lt; k) 
						reservoir[j] = stream[i];             
		} 

		System.out.println(&quot;Following are k randomly selected items&quot;); 
		System.out.println(Arrays.toString(reservoir)); 
} 
</code></pre>
<p><strong>315. Count of Smaller Numbers After Self</strong></p>
<p>When we try to insert a number, the total number of smaller number would be adding dup and sum of the nodes where we turn right.</p>
<pre><code>public class Solution {
    class Node {
        Node left, right;
        int val, sum;
				int dup = 1;  // count of same numbers
        public Node(int v, int s) {
            val = v;
            sum = s;
        }
    }
    public List&lt;Integer&gt; countSmaller(int[] nums) {
        Integer[] ans = new Integer[nums.length];
        Node root = null;
        for (int i = nums.length - 1; i &gt;= 0; i--) {
            root = insert(nums[i], root, ans, i, 0);
        }
        return Arrays.asList(ans);
    }
    private Node insert(int num, Node node, Integer[] ans, int i, int preSum) {
        if (node == null) {
            node = new Node(num, 0);
            ans[i] = preSum;
        } else if (node.val == num) {
            node.dup++;
            ans[i] = preSum + node.sum;
        } else if (node.val &gt; num) {
            node.sum++;
            node.left = insert(num, node.left, ans, i, preSum);
        } else {
            node.right = insert(num, node.right, ans, i, preSum + node.dup + node.sum);
        }
        return node;
    }
}
</code></pre>
<p><strong>406. Queue Reconstruction by Height</strong></p>
<p>Sort the (height, count of higher before self) by (descending, ascending). Insert by count of higher before.</p>
<pre><code>class Solution {
    public int[][] reconstructQueue(int[][] people) {
        if (people == null || people.length == 0 || people[0].length == 0)
            return new int[0][0];
            
        Arrays.sort(people, new Comparator&lt;int[]&gt;() {
            public int compare(int[] a, int[] b) {
                if (b[0] == a[0]) return a[1] - b[1];
                return b[0] - a[0];
            }
        });
        
        int n = people.length;
        ArrayList&lt;int[]&gt; tmp = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; n; i++)
            tmp.add(people[i][1], new int[]{people[i][0], people[i][1]});

        int[][] res = new int[people.length][2];
        int i = 0;
        for (int[] k : tmp) {
            res[i][0] = k[0];
            res[i++][1] = k[1];
        }
        
        return res;
    }
}
</code></pre>
<p><strong>1027. Longest Arithmetic Sequence</strong></p>
<pre><code>public int longestArithSeqLength(int[] A) {
		int res = 2, n = A.length;
		HashMap&lt;Integer, Integer&gt;[] dp = new HashMap[n];
		for (int j = 0; j &lt; A.length; j++) {
				dp[j] = new HashMap&lt;&gt;();
				for (int i = 0; i &lt; j; i++) {
						int d = A[j] - A[i];
						dp[j].put(d, dp[i].getOrDefault(d, 1) + 1);
						res = Math.max(res, dp[j].get(d));
				}
		}
		return res;
}
</code></pre>
<p><strong>Decreasing Subsequences</strong></p>
<p>The number of decreasing subsequence partitions is equal to the length of the longest non-decreasing subsequence.</p>
<pre><code>public static int leastSubsequences(int... nums) {
		int[] piles = new int[nums.length];
		int size = 0;
		for (int val : nums) {
				int pile = binarySearch(piles, 0, size, val);
				piles[pile] = val;
				if (pile == size) size++;
		 }
		return size;
}

// find first element greater than target
public static int binarySearch(int[] nums, int lo, int hi, int target) {
		while (lo &lt; hi) {
				int mid = (lo + hi) &gt;&gt;&gt; 1;
				if (nums[mid] &lt;= target) {
						lo = mid + 1;
				} else {
						hi = mid;
				}
		}
		return lo;
}
</code></pre>
<p><strong>683. K Empty Slots</strong></p>
<pre><code>public int kEmptySlots(int[] flowers, int k) {
    TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;();
        
    for (int i = 0; i &lt; flowers.length; i++) {
        int xc = flowers[i], xl = xc - (k + 1), xr = xc + (k + 1);
            
        Integer l = set.lower(xc);
        if (l != null &amp;&amp; l == xl) return i + 1;
        
        Integer r = set.higher(xc);
        if (r != null &amp;&amp; r == xr) return i + 1;
        
        set.add(xc);
    }
    
    return -1;
}
</code></pre>
<p>**Kruskal's Minimum Spanning Tree **</p>
<ol>
<li>Sort all the edges in non-decreasing order of their weight.</li>
<li>Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If cycle is not formed, include this edge. Else, discard it.</li>
<li>Repeat step#2 until there are (V-1) edges in the spanning tree.</li>
</ol>
<pre><code>
// The main function to construct MST using Kruskal's algorithm 
void KruskalMST() 
{ 
		Edge result[] = new Edge[V];  // Tnis will store the resultant MST 
		int e = 0;  // An index variable, used for result[] 
		int i = 0;  // An index variable, used for sorted edges 
		for (i=0; i&lt;V; ++i) 
				result[i] = new Edge(); 

		// Step 1:  Sort all the edges in non-decreasing order of their 
		// weight.  If we are not allowed to change the given graph, we 
		// can create a copy of array of edges 
		Arrays.sort(edge); 

		// Allocate memory for creating V ssubsets 
		subset subsets[] = new subset[V]; 
		for(i=0; i&lt;V; ++i) 
				subsets[i]=new subset(); 

		// Create V subsets with single elements 
		for (int v = 0; v &lt; V; ++v) 
		{ 
				subsets[v].parent = v; 
				subsets[v].rank = 0; 
		} 

		i = 0;  // Index used to pick next edge 

		// Number of edges to be taken is equal to V-1 
		while (e &lt; V - 1) 
		{ 
				// Step 2: Pick the smallest edge. And increment  
				// the index for next iteration 
				Edge next_edge = new Edge(); 
				next_edge = edge[i++]; 

				int x = find(subsets, next_edge.src); 
				int y = find(subsets, next_edge.dest); 

				// If including this edge does't cause cycle, 
				// include it in result and increment the index  
				// of result for next edge 
				if (x != y) 
				{ 
						result[e++] = next_edge; 
						Union(subsets, x, y); 
				} 
				// Else discard the next_edge 
		} 

		// print the contents of result[] to display 
		// the built MST 
		System.out.println(&quot;Following are the edges in &quot; +  
																 &quot;the constructed MST&quot;); 
		for (i = 0; i &lt; e; ++i) 
				System.out.println(result[i].src+&quot; -- &quot; +  
							 result[i].dest+&quot; == &quot; + result[i].weight); 
} 
</code></pre>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://ywang412.github.io/tag/fy8llECIr" class="tag">
                    LeetCode
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://ywang412.github.io/post/resume">
                  <h3 class="post-title">
                    Resume
                  </h3>
                </a>
              </div>
            

            
              

              
                <div id="disqus_thread" data-aos="fade-in"></div>
              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  

  
    <script src="https://unpkg.com/disqusjs@1.1/dist/disqus.js"></script>
    <script>

    var options = {
      shortname: 'ywang412',
      apikey: 'gmr5wORrpUmczJ0fs6x1CjNX2WgIP2riU2sSqLrIo6Idh3GkyiY8WIpUwBaP70X5',
    }
    if ('') {
      options.api = ''
    }
    var dsqjs = new DisqusJS(options)

    </script>
  




  </body>
</html>
