<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ywang412.github.io</id>
    <title>Yu&apos;s Github</title>
    <updated>2019-06-26T06:39:06.905Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ywang412.github.io"/>
    <link rel="self" href="https://ywang412.github.io/atom.xml"/>
    <subtitle>Java by day, Scala by night</subtitle>
    <logo>https://ywang412.github.io/images/avatar.png</logo>
    <icon>https://ywang412.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Yu&apos;s Github</rights>
    <entry>
        <title type="html"><![CDATA[Pitfalls in DFS/BFS algorithm]]></title>
        <id>https://ywang412.github.io/post/dfsbfs-algorithm</id>
        <link href="https://ywang412.github.io/post/dfsbfs-algorithm">
        </link>
        <updated>2019-06-21T10:03:19.000Z</updated>
        <content type="html"><![CDATA[<p>Some pitfalls in DFS/BFS algorithm that requires extra caution.</p>
<p><strong>Leetcode 542. 01 Matrix</strong></p>
<p>To find the shortest distance from 1 to nearest 0, It is important to truncate when current dist from a 0 is already larger than previous found dfs path originated from another 0.</p>
<pre><code>public void dfs(int[][] res, boolean[][] visited, int i, int j, int dist) {
        if (i &lt; 0 || i &gt;= res.length || j &lt; 0 || j &gt;= res[0].length || res[i][j] &lt;= dist) return;
        res[i][j] = Math.min(dist, res[i][j]);
        visited[i][j] = true;
        dfs(res, visited, i - 1, j, dist + 1);
        dfs(res, visited, i + 1, j, dist + 1);
        dfs(res, visited, i, j - 1, dist + 1);
        dfs(res, visited, i, j + 1, dist + 1); 
        visited[i][j] = false;
    }
</code></pre>
<p><strong>LeetCode 39. Combination Sum</strong>
Because of passing by reference, when adding a path to result list, the added path is a deep copy to avoid further changes. To prevent duplicated path, each dfs entry will set the minimum index of the range that following dfs can choose from.</p>
<pre><code>public void dfs(int[] candidates, int start, int cur, int target, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res) {
     if (cur &gt; target) return;
     if (cur == target) { 
         List&lt;Integer&gt; pathToAdd = new LinkedList&lt;&gt;(path);
         res.add(pathToAdd);
         return;
     }
     for (int i = start; i &lt; candidates.length; i++) {
         path.add(candidates[i]);
         dfs(candidates, i, cur + candidates[i], target, path, res);
         path.remove(path.size() - 1);
     }
</code></pre>
<p><strong>LeetCode 675. Cut Off Trees for Golf Event</strong>
Whenever a new position is added to the BFS queue, the visited matrix or set need to mark that as soon as possible to avoid revisiting it. Comparing string (Char of 2 bytes) is much more time consuming than comparing Integer (4 bytes).</p>
<pre><code>public int bfs(int[] pre, int[] cur, List&lt;List&lt;Integer&gt;&gt; forest) {
		int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
		Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;();
		Set&lt;String&gt; visited = new HashSet&lt;&gt;();
		pre[2] = 0;
		q.offer(pre); 
		visited.add(pre[0] + &quot;#&quot; + pre[1]);
		while (!q.isEmpty()) {   
				int[] temp = q.poll(); 
				// if ((temp[0] + &quot;#&quot; + temp[1]).equals(cur[0] + &quot;#&quot; + cur[1])) { will TLE
				if ((temp[0] == cur[0]) &amp;&amp; (temp[1] == cur[1])) {
						return temp[2];
				}
				else {
						for (int[] dir : dirs) {
								int i = temp[0] + dir[0];
								int j = temp[1] + dir[1];
								if (i &gt;= 0 &amp;&amp; i &lt; forest.size() &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; forest.get(i).size() &amp;&amp; forest.get(i).get(j) &gt; 0 &amp;&amp; !visited.contains(i + &quot;#&quot; + j)) {
										q.offer(new int[]{i, j, temp[2] + 1});
										visited.add(i + &quot;#&quot; + j);
								}
						}
				} 
		}
		return -1;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Coding tricks of Java syntax ]]></title>
        <id>https://ywang412.github.io/post/leetcode-118-pascals-triangle-java-type-erasure</id>
        <link href="https://ywang412.github.io/post/leetcode-118-pascals-triangle-java-type-erasure">
        </link>
        <updated>2019-06-19T18:49:32.000Z</updated>
        <content type="html"><![CDATA[<p>LeetCode has greatly sharpened my programming skills. A few examples are listed here.</p>
<p><strong>LeetCode 118</strong> Pascal's Triangle<br>
Due to Java type erasure, in order to instantiate a list of list, one can use
<code>List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</code>
or
<code>List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();</code>
Here <code>List&lt;Integer&gt;</code> becomes type definition.</p>
<p><strong>LeetCode 929</strong> requires removing of &quot;.&quot; in a string. It turns out &quot;.&quot; and &quot;*&quot; are metaCharacters used in a regex. From JDK 7 manual, the replaceAll() takes regex input and therefore &quot;.&quot; was recognized  as &quot;any character&quot;. Two backward slashes will escape dot character. Yet it is OK to use replace() API which can treat the &quot;.&quot; as a dot character.</p>
<p><em>JDK7</em></p>
<pre><code>String	replace(char oldChar, char newChar)
Returns a new string resulting from replacing all occurrences of oldChar in this string with newChar.
String	replaceAll(String regex, String replacement)
Replaces each substring of this string that matches the given regular expression with the given replacement.
String	replaceFirst(String regex, String replacement)
Replaces the first substring of this string that matches the given regular expression with the given replacement.
</code></pre>
<p>The solution is below,</p>
<pre><code>class Solution {
    public static int numUniqueEmails(String[] emails) {
        if (emails.length &lt; 1) return 0;

        Set&lt;String&gt; set = new HashSet&lt;&gt;();
        for (String email : emails) {
            String[] adds = email.split(&quot;@&quot;);
            String name = adds[0]; 
            if (name.indexOf(&quot;+&quot;) &gt;= 0) name = name.substring(0, name.indexOf(&quot;+&quot;));
            name = name.replaceAll(&quot;\\.&quot;,&quot;&quot;);
            set.add(name + &quot;@&quot; + adds[1]);
        }
        return set.size();
    }

    public static void main(String[] args) {
        String[] t = new String[]{&quot;testemail@leetcode.com&quot;,&quot;testemail1@leetcode.com&quot;,&quot;testemail+david@lee.tcode.com&quot;};
        System.out.println(numUniqueEmails(t));
    }
}
</code></pre>
<p><strong>LeetCode 791. Custom Sort String</strong>
Below is the code snippet to create a priorityqueue with custom comparator.</p>
<pre><code>			PriorityQueue&lt;Character&gt; queue = new PriorityQueue&lt;&gt;(new Comparator&lt;Character&gt;(){
					public int compare(Character a, Character b) {
							return Integer.compare(map.getOrDefault(a, Integer.MAX_VALUE), map.getOrDefault(b, Integer.MAX_VALUE));
					}
			});
</code></pre>
<p><strong>LeetCode 957. Prison Cells After N Days</strong></p>
<p>The state change cycle might start at a state that is not the initital state, therefore a map is used to record past state at each day. When fastforward the N using N % cycle, the N could already be 0 and the last state change should be skipped.</p>
<pre><code>while (N &gt; 0) { 
		StringBuilder sb = new StringBuilder();
		for (int j : cells) sb.append(j);
		if (map.containsKey(sb.toString())) {
				N %= (N - map.get(sb.toString()));
		}
		map.put(sb.toString(), N);
		if (N &gt;= 1) {
				N--;
				cells = prisonAfter1Day(cells);
		}
}
</code></pre>
<p><strong>LeetCode 957. K Empty Slots</strong></p>
<p>Java Primitive types such as &quot;int&quot; are not nullable. Boxed version such as &quot;Integer&quot; are nullable. Therefore, when get nullable value from Java collections, the null check can only performed on the boxed data type.</p>
<pre><code>TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;();
Integer low = set.floor(bulbs[i]);
Integer high = set.ceiling(bulbs[i]);
if (low != null &amp;&amp; bulbs[i] - low - 1 == K) return i + 1;
if (high != null &amp;&amp; high - bulbs[i] - 1 == K) return i + 1;            
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Publishing a personal programming blog on Github.io using Gridea]]></title>
        <id>https://ywang412.github.io/post/publishing-personal-website-on-githubio-using-gridea</id>
        <link href="https://ywang412.github.io/post/publishing-personal-website-on-githubio-using-gridea">
        </link>
        <updated>2019-06-07T00:44:23.000Z</updated>
        <content type="html"><![CDATA[<p>I've always wanted to start a programmer's blog because I learned a huge amount from others' tech blog. But hosting and maintaining a blog website could require lots of effort. I came across this Gridea tool (https://github.com/getgridea/gridea) which features html/css static content generation and github.io auto publishing. It helps immensely writing a programming blog.</p>
<p>After downloading and installing the Gridea tool, the first thing is to link it in order to publish on github.io. The settings tab is quite self-explanatory. <img src="https://ywang412.github.io/post-images/1561227293749.png" alt=""></p>
<p>The publishing will require a github token for authentication which can be generated here https://github.com/settings/tokens . Remember to use <strong>repo scope</strong> access token to reduce vulnerability.
<img src="https://ywang412.github.io/post-images/1561227595716.png" alt=""></p>
<p>The best thing about Gridea is auto-generation of markdown tags and corresponding hotkeys. <img src="https://ywang412.github.io/post-images/1561227880490.png" alt=""></p>
<pre><code>object SumOfMultiples {
  def sum(factors: Set[Int], limit: Int): Int = {
    factors.map(x =&gt; Stream.range(1, limit / x + 1).map(_ * x).takeWhile(_ &lt; limit).toList).flatMap(x =&gt; x).sum
  }
}
</code></pre>
<p>The last thing I want to mention is the comment function. Currently, only Gitalk and Disqus third-party API are allowed. I choose Disqus for its simpler setting. <img src="https://ywang412.github.io/post-images/1561228499134.png" alt="">
Register a free account on disqus and create a new application. The public api key will appear in the application confirmation page. The short name can be located on the admin page. <img src="https://ywang412.github.io/post-images/1561229354797.png" alt=""></p>
<p>I enjoyed very much the writing and seeing the outcome on github.io. Now I have a personal blog that motivates me to write once a while to share knowledge and help others. Kudos!</p>
]]></content>
    </entry>
</feed>