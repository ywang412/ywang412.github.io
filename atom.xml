<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ywang412.github.io</id>
    <title>Yu&apos;s Github</title>
    <updated>2019-09-06T04:29:06.351Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ywang412.github.io"/>
    <link rel="self" href="https://ywang412.github.io/atom.xml"/>
    <subtitle>Java by day, Scala by night</subtitle>
    <logo>https://ywang412.github.io/images/avatar.png</logo>
    <icon>https://ywang412.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Yu&apos;s Github</rights>
    <entry>
        <title type="html"><![CDATA[Semaphore vs Lock]]></title>
        <id>https://ywang412.github.io/post/semaphore-vs-lock</id>
        <link href="https://ywang412.github.io/post/semaphore-vs-lock">
        </link>
        <updated>2019-09-01T13:36:52.000Z</updated>
        <content type="html"><![CDATA[<p><strong>1114. Print in Order</strong></p>
<pre><code>class Foo {
    
    private volatile boolean onePrinted;
    private volatile boolean twoPrinted;

    public Foo() {
        onePrinted = false;
        twoPrinted = false;        
    }

    public synchronized void first(Runnable printFirst) throws InterruptedException {
        
        // printFirst.run() outputs &quot;first&quot;. Do not change or remove this line.
        printFirst.run();
        onePrinted = true;
        notifyAll();
    }

    public synchronized void second(Runnable printSecond) throws InterruptedException {
        while(!onePrinted) {
            wait();
        }
        // printSecond.run() outputs &quot;second&quot;. Do not change or remove this line.
        printSecond.run();
        twoPrinted = true;
        notifyAll();
    }

    public synchronized void third(Runnable printThird) throws InterruptedException {
        while(!twoPrinted) {
            wait();
        }
        // printThird.run() outputs &quot;third&quot;. Do not change or remove this line.
        printThird.run();
    }
}
</code></pre>
<pre><code>import java.util.concurrent.*;
class Foo {
    Semaphore run2, run3;

    public Foo() {
        run2 = new Semaphore(0);
        run3 = new Semaphore(0);
    }

    public void first(Runnable printFirst) throws InterruptedException {
        printFirst.run();
        run2.release();
    }

    public void second(Runnable printSecond) throws InterruptedException {
        run2.acquire();
        printSecond.run();
        run3.release();
    }

    public void third(Runnable printThird) throws InterruptedException {
        run3.acquire(); 
        printThird.run();
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2D Matrix ]]></title>
        <id>https://ywang412.github.io/post/candy-crush</id>
        <link href="https://ywang412.github.io/post/candy-crush">
        </link>
        <updated>2019-08-22T22:01:49.000Z</updated>
        <content type="html"><![CDATA[<p><strong>723. Candy Crush</strong></p>
<pre><code>class Solution {
    public int[][] candyCrush(int[][] board) {
        int R = board.length, C = board[0].length;
        boolean todo = false;
        for (int r = 0; r &lt; R; ++r) {
            for (int c = 0; c + 2 &lt; C; ++c) {
                int v = Math.abs(board[r][c]);
                if (v != 0 &amp;&amp; v == Math.abs(board[r][c+1]) &amp;&amp; v == Math.abs(board[r][c+2])) {
                    board[r][c] = board[r][c+1] = board[r][c+2] = -v;
                    todo = true;
                }
            }
        }
        for (int r = 0; r + 2 &lt; R; ++r) {
            for (int c = 0; c &lt; C; ++c) {
                int v = Math.abs(board[r][c]);
                if (v != 0 &amp;&amp; v == Math.abs(board[r+1][c]) &amp;&amp; v == Math.abs(board[r+2][c])) {
                    board[r][c] = board[r+1][c] = board[r+2][c] = -v;
                    todo = true;
                }
            }
        }

        for (int c = 0; c &lt; C; ++c) {
            int wr = R - 1;
            for (int r = R-1; r &gt;= 0; --r)
                if (board[r][c] &gt; 0)
                    board[wr--][c] = board[r][c];
            while (wr &gt;= 0)
                board[wr--][c] = 0;
        }

        return todo ? candyCrush(board) : board;
    }
}
</code></pre>
<p><strong>85. Maximal Rectangle</strong></p>
<pre><code>class Solution {

    public int maximalRectangle(char[][] matrix) {
        if(matrix.length == 0) return 0;
        int m = matrix.length;
        int n = matrix[0].length;

        int[] left = new int[n]; // initialize left as the leftmost boundary possible
        int[] right = new int[n];
        int[] height = new int[n];

        Arrays.fill(right, n - 1); // initialize right as the rightmost boundary possible

        int maxarea = 0;
        for(int i = 0; i &lt; m; i++) {
            int cur_left = 0, cur_right = n - 1;
            // update height
            for(int j = 0; j &lt; n; j++) {
                if(matrix[i][j] == '1') height[j]++;
                else height[j] = 0;
            }
            // update left
            for(int j=0; j&lt;n; j++) {
                if(matrix[i][j]=='1') left[j]=Math.max(left[j],cur_left);
                //00100
                //01210
                
                //left[j] at 2
                
                
                else {left[j]=0; cur_left=j+1;}
            }
            // update right
            for(int j = n - 1; j &gt;= 0; j--) {
                if(matrix[i][j] == '1') right[j] = Math.min(right[j], cur_right);
                else {right[j] = n - 1; cur_right = j - 1;}    
            }
            // update area
            for(int j = 0; j &lt; n; j++) {
                maxarea = Math.max(maxarea, (right[j] - left[j] + 1) * height[j]);
            }
        }
        return maxarea;
        
    }
}
</code></pre>
<p><strong>361. Bomb Enemy</strong></p>
<pre><code>class Solution {
     public int maxKilledEnemies(char[][] grid) {
        if(grid == null || grid.length == 0 ||  grid[0].length == 0) return 0;
        int max = 0;
        int row = 0;
        int[] col = new int[grid[0].length];
        for(int i = 0; i&lt;grid.length; i++){
            for(int j = 0; j&lt;grid[0].length;j++){
                if(grid[i][j] == 'W') continue;
                if(j == 0 || grid[i][j-1] == 'W'){
                     row = killedEnemiesRow(grid, i, j);
                }
                if(i == 0 || grid[i-1][j] == 'W'){
                     col[j] = killedEnemiesCol(grid,i,j);
                }
                if(grid[i][j] == '0'){
                    max = (row + col[j] &gt; max) ? row + col[j] : max;
                }
            }

        }

        return max;
    }

    //calculate killed enemies for row i from column j
    private int killedEnemiesRow(char[][] grid, int i, int j){
        int num = 0;
        while(j &lt;= grid[0].length-1 &amp;&amp; grid[i][j] != 'W'){
            if(grid[i][j] == 'E') num++;
            j++;
        }
        return num;
    }
    //calculate killed enemies for  column j from row i
    private int killedEnemiesCol(char[][] grid, int i, int j){
        int num = 0;
        while(i &lt;= grid.length -1 &amp;&amp; grid[i][j] != 'W'){
            if(grid[i][j] == 'E') num++;
            i++;
        }
        return num;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Examples of System Design]]></title>
        <id>https://ywang412.github.io/post/system-design</id>
        <link href="https://ywang412.github.io/post/system-design">
        </link>
        <updated>2019-08-03T20:48:51.000Z</updated>
        <content type="html"><![CDATA[<p>byte 1 byte -128 to 127.
short 2 bytes -32,768 to 32,767.
int 4 bytes -2,147,483,648 to 2,147,483,647.
long 8 bytes -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807.</p>
<p><strong>Designing TinyURL</strong></p>
<p>Encoding actual URL
We can compute a unique hash (e.g., MD5 or SHA256, etc.) of the given URL. The hash can then be encoded for displaying. This encoding could be base36 ([a-z ,0-9]) or base62 ([A-Z, a-z, 0-9]) and if we add ‘-’ and ‘.’ we can use base64 encoding. A reasonable question would be, what should be the length of the short key? 6, 8 or 10 characters.</p>
<p>Using base64 encoding, a 6 letter long key would result in 64^6 = ~68.7 billion possible strings
Using base64 encoding, an 8 letter long key would result in 64^8 = ~281 trillion possible strings</p>
<p>With 68.7B unique strings, let’s assume six letter keys would suffice for our system.</p>
<p>If we use the MD5 algorithm as our hash function, it’ll produce a 128-bit hash value. After base64 encoding, we’ll get a string having more than 21 characters (since each base64 character encodes 6 bits of the hash value). Since we only have space for 8 characters per short key, how will we choose our key then? We can take the first 6 (or 8) letters for the key. This could result in key duplication though, upon which we can choose some other characters out of the encoding string or swap some characters.</p>
<p>What are different issues with our solution? We have the following couple of problems with our encoding scheme:</p>
<p>If multiple users enter the same URL, they can get the same shortened URL, which is not acceptable.
What if parts of the URL are URL-encoded? e.g., http://www.educative.io/distributed.php?id=design, and http://www.educative.io/distributed.php%3Fid%3Ddesign are identical except for the URL encoding.
Workaround for the issues: We can append an increasing sequence number to each input URL to make it unique, and then generate a hash of it. We don’t need to store this sequence number in the databases, though. Possible problems with this approach could be an ever-increasing sequence number. Can it overflow? Appending an increasing sequence number will also impact the performance of the service.</p>
<p>Another solution could be to append user id (which should be unique) to the input URL. However, if the user has not signed in, we would have to ask the user to choose a uniqueness key. Even after this, if we have a conflict, we have to keep generating a key until we get a unique one.</p>
<p><img src="https://ywang412.github.io/post-images/1565756686530.png" alt="">
<img src="https://ywang412.github.io/post-images/1565754688299.png" alt=""></p>
<p><strong>Designing Pastebin</strong></p>
<p><img src="https://ywang412.github.io/post-images/1565757376688.png" alt="">
<img src="https://ywang412.github.io/post-images/1565756747081.png" alt=""></p>
<p><strong>Design Instagram</strong></p>
<p><img src="https://ywang412.github.io/post-images/1565757489241.png" alt="">
a. Partitioning based on UserID Let’s assume we shard based on the ‘UserID’ so that we can keep all photos of a user on the same shard. If one DB shard is 1TB, we will need four shards to store 3.7TB of data. Let’s assume for better performance and scalability we keep 10 shards.</p>
<p>So we’ll find the shard number by UserID % 10 and then store the data there. To uniquely identify any photo in our system, we can append shard number with each PhotoID.</p>
<p>How can we generate PhotoIDs? Each DB shard can have its own auto-increment sequence for PhotoIDs and since we will append ShardID with each PhotoID, it will make it unique throughout our system.</p>
<p>What are the different issues with this partitioning scheme?</p>
<p>How would we handle hot users? Several people follow such hot users and a lot of other people see any photo they upload.
Some users will have a lot of photos compared to others, thus making a non-uniform distribution of storage.
What if we cannot store all pictures of a user on one shard? If we distribute photos of a user onto multiple shards will it cause higher latencies?
Storing all photos of a user on one shard can cause issues like unavailability of all of the user’s data if that shard is down or higher latency if it is serving high load etc.
b. Partitioning based on PhotoID If we can generate unique PhotoIDs first and then find a shard number through “PhotoID % 10”, the above problems will have been solved. We would not need to append ShardID with PhotoID in this case as PhotoID will itself be unique throughout the system.</p>
<p>How can we generate PhotoIDs? Here we cannot have an auto-incrementing sequence in each shard to define PhotoID because we need to know PhotoID first to find the shard where it will be stored. One solution could be that we dedicate a separate database instance to generate auto-incrementing IDs. If our PhotoID can fit into 64 bits, we can define a table containing only a 64 bit ID field. So whenever we would like to add a photo in our system, we can insert a new row in this table and take that ID to be our PhotoID of the new photo.</p>
<p>Wouldn’t this key generating DB be a single point of failure? Yes, it would be. A workaround for that could be defining two such databases with one generating even numbered IDs and the other odd numbered. For the MySQL, the following script can define such sequences:</p>
<pre><code>KeyGeneratingServer1:
auto-increment-increment = 2
auto-increment-offset = 1 
KeyGeneratingServer2:
auto-increment-increment = 2
auto-increment-offset = 2
</code></pre>
<p>We can put a load balancer in front of both of these databases to round robin between them and to deal with downtime. Both these servers could be out of sync with one generating more keys than the other, but this will not cause any issue in our system. We can extend this design by defining separate ID tables for Users, Photo-Comments, or other objects present in our system.</p>
<p>Alternately, we can implement a ‘key’ generation scheme similar to what we have discussed in Designing a URL Shortening service like TinyURL.</p>
<p><img src="https://ywang412.github.io/post-images/1565757623378.png" alt=""></p>
<p><strong>Design Dropbox</strong></p>
<p>The metadata Database should be storing information about following objects:</p>
<p>Chunks
Files
User
Devices
Workspace (sync folders)</p>
<p><img src="https://ywang412.github.io/post-images/1565757709181.png" alt="">
<img src="https://ywang412.github.io/post-images/1565757739488.png" alt=""></p>
<p><strong>Designing Messenger</strong></p>
<p><img src="https://ywang412.github.io/post-images/1566064813925.png" alt="">
<img src="https://ywang412.github.io/post-images/1566064820748.png" alt=""></p>
<p><strong>Designing Twitter</strong></p>
<p><img src="https://ywang412.github.io/post-images/1566067729831.png" alt="">
<img src="https://ywang412.github.io/post-images/1566067734387.png" alt=""></p>
<p><strong>Designing Youtube</strong></p>
<p>At a high-level we would need the following components:</p>
<p>Processing Queue: Each uploaded video will be pushed to a processing queue to be de-queued later for encoding, thumbnail generation, and storage.
Encoder: To encode each uploaded video into multiple formats.
Thumbnails generator: To generate a few thumbnails for each video.
Video and Thumbnail storage: To store video and thumbnail files in some distributed file storage.
User Database: To store user’s information, e.g., name, email, address, etc.
Video metadata storage: A metadata database to store all the information about videos like title, file path in the system, uploading user, total views, likes, dislikes, etc. It will also be used to store all the video comments.</p>
<p><img src="https://ywang412.github.io/post-images/1566070090262.png" alt=""></p>
<p><strong>Design Rate Limiter</strong></p>
<p><img src="https://ywang412.github.io/post-images/1566091665748.png" alt=""></p>
<p>fixed window
<img src="https://ywang412.github.io/post-images/1566091776264.png" alt="">
sliding wondow
<img src="https://ywang412.github.io/post-images/1566091784751.png" alt="">
bucket counter
if we have an hourly rate limit we can keep a count for each minute and calculate the sum of all counters in the past hour when we receive a new request to calculate the throttling limit</p>
<p><strong>Design Typeahead Suggestion</strong></p>
<p>Should we have case insensitive trie? For simplicity and search use-case, let’s assume our data is case insensitive.</p>
<p>How to find top suggestion? Now that we can find all the terms for a given prefix, how can we find the top 10 terms for the given prefix? One simple solution could be to store the count of searches that terminated at each node, e.g., if users have searched about ‘CAPTAIN’ 100 times and ‘CAPTION’ 500 times, we can store this number with the last character of the phrase. Now if the user types ‘CAP’ we know the top most searched word under the prefix ‘CAP’ is ‘CAPTION’. So, to find the top suggestions for a given prefix, we can traverse the sub-tree under it.</p>
<p>Given a prefix, how much time will it take to traverse its sub-tree? Given the amount of data we need to index, we should expect a huge tree. Even traversing a sub-tree would take really long, e.g., the phrase ‘system design interview questions’ is 30 levels deep. Since we have very strict latency requirements we do need to improve the efficiency of our solution.</p>
<p>Can we store top suggestions with each node? This can surely speed up our searches but will require a lot of extra storage. We can store top 10 suggestions at each node that we can return to the user. We have to bear the big increase in our storage capacity to achieve the required efficiency.</p>
<p>We can optimize our storage by storing only references of the terminal nodes rather than storing the entire phrase. To find the suggested terms we need to traverse back using the parent reference from the terminal node. We will also need to store the frequency with each reference to keep track of top suggestions.</p>
<p>How would we build this trie? We can efficiently build our trie bottom up. Each parent node will recursively call all the child nodes to calculate their top suggestions and their counts. Parent nodes will combine top suggestions from all of their children to determine their top suggestions.</p>
<p>How to update the trie? Assuming five billion searches every day, which would give us approximately 60K queries per second. If we try to update our trie for every query it’ll be extremely resource intensive and this can hamper our read requests, too. One solution to handle this could be to update our trie offline after a certain interval.</p>
<p>As the new queries come in we can log them and also track their frequencies. Either we can log every query or do sampling and log every 1000th query. For example, if we don’t want to show a term which is searched for less than 1000 times, it’s safe to log every 1000th searched term.</p>
<p>We can have a Map-Reduce (MR) set-up to process all the logging data periodically say every hour. These MR jobs will calculate frequencies of all searched terms in the past hour. We can then update our trie with this new data. We can take the current snapshot of the trie and update it with all the new terms and their frequencies. We should do this offline as we don’t want our read queries to be blocked by update trie requests. We can have two options:</p>
<p>We can make a copy of the trie on each server to update it offline. Once done we can switch to start using it and discard the old one.
Another option is we can have a master-slave configuration for each trie server. We can update slave while the master is serving traffic. Once the update is complete, we can make the slave our new master. We can later update our old master, which can then start serving traffic, too.
How can we update the frequencies of typeahead suggestions? Since we are storing frequencies of our typeahead suggestions with each node, we need to update them too! We can update only differences in frequencies rather than recounting all search terms from scratch. If we’re keeping count of all the terms searched in last 10 days, we’ll need to subtract the counts from the time period no longer included and add the counts for the new time period being included. We can add and subtract frequencies based on Exponential Moving Average (EMA) of each term. In EMA, we give more weight to the latest data. It’s also known as the exponentially weighted moving average.</p>
<p>After inserting a new term in the trie, we’ll go to the terminal node of the phrase and increase its frequency. Since we’re storing the top 10 queries in each node, it is possible that this particular search term jumped into the top 10 queries of a few other nodes. So, we need to update the top 10 queries of those nodes then. We have to traverse back from the node to all the way up to the root. For every parent, we check if the current query is part of the top 10. If so, we update the corresponding frequency. If not, we check if the current query’s frequency is high enough to be a part of the top 10. If so, we insert this new term and remove the term with the lowest frequency.</p>
<p>How can we remove a term from the trie? Let's say we have to remove a term from the trie because of some legal issue or hate or piracy etc. We can completely remove such terms from the trie when the regular update happens, meanwhile, we can add a filtering layer on each server which will remove any such term before sending them to users.</p>
<p>What could be different ranking criteria for suggestions? In addition to a simple count, for terms ranking, we have to consider other factors too, e.g., freshness, user location, language, demographics, personal history etc.</p>
<p>Typeahead Client
We can perform the following optimizations on the client side to improve user’s experience:</p>
<p>The client should only try hitting the server if the user has not pressed any key for 50ms.
If the user is constantly typing, the client can cancel the in-progress requests.
Initially, the client can wait until the user enters a couple of characters.
Clients can pre-fetch some data from the server to save future requests.
Clients can store the recent history of suggestions locally. Recent history has a very high rate of being reused.
Establishing an early connection with the server turns out to be one of the most important factors. As soon as the user opens the search engine website, the client can open a connection with the server. So when a user types in the first character, the client doesn’t waste time in establishing the connection.
The server can push some part of their cache to CDNs and Internet Service Providers (ISPs) for efficiency.</p>
<p><strong>Designing Twitter Search</strong></p>
<p><img src="https://ywang412.github.io/post-images/1566094473812.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Monotonic Stack]]></title>
        <id>https://ywang412.github.io/post/monotonic-stack</id>
        <link href="https://ywang412.github.io/post/monotonic-stack">
        </link>
        <updated>2019-07-28T11:40:22.000Z</updated>
        <content type="html"><![CDATA[<p><strong>739. Daily Temperatures and 496. Next Greater Element I</strong></p>
<pre><code>class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        int[] ret = new int[temperatures.length];
        for(int i = 0; i &lt; temperatures.length; i++) {
            while(!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) {
                int idx = stack.pop();
                ret[idx] = i - idx;
            }
            stack.push(i);
        }
        return ret;
    }
}
</code></pre>
<p><strong>Largest Rectangle in Histogram</strong></p>
<pre><code>public class Solution {
    public int largestRectangleArea(int[] height) {
        int len = height.length;
        Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;();
        int maxArea = 0;
        int i = 0;
        while(i &lt;= len){
            int h = (i == len ? 0 : height[i]);
            if(s.isEmpty() || h &gt;= height[s.peek()]){
                s.push(i);
                i++;
            }else{
                int tp = s.pop();
                maxArea = Math.max(maxArea, height[tp] * (s.isEmpty() ? i : i - 1 - s.peek()));
                 
            }
        }
        return maxArea;
    }
}
</code></pre>
<p><strong>239. Sliding Window Maximum</strong></p>
<pre><code>class Solution {
    public int[] maxSlidingWindow(int[] a, int k) {		
            if (a == null || k &lt;= 0) {
                return new int[0];
            }
            int n = a.length;
            int[] r = new int[n-k+1];
            int ri = 0;
            // store index
            Deque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();
            for (int i = 0; i &lt; a.length; i++) {
                // remove numbers out of range k
                while (!q.isEmpty() &amp;&amp; q.peek() &lt; i - k + 1) {
                    q.poll();
                }
                // remove smaller numbers in k range as they are useless
                while (!q.isEmpty() &amp;&amp; a[q.peekLast()] &lt; a[i]) {
                    q.pollLast();
                }
                // q contains index... r contains content
                q.offer(i);
                if (i &gt;= k - 1) {
                    r[ri++] = a[q.peek()];
                }
            }
            return r;
        }
}
</code></pre>
<p><strong>862. Shortest Subarray with Sum at Least K</strong></p>
<pre><code>class Solution {
    public int shortestSubarray(int[] A, int K) {
        int N = A.length, res = N + 1;
        int[] B = new int[N + 1];
        for (int i = 0; i &lt; N; i++) 
            B[i + 1] = B[i] + A[i];
        Deque&lt;Integer&gt; d = new ArrayDeque&lt;&gt;();
        for (int i = 0; i &lt; N + 1; i++) {
            while (d.size() &gt; 0 &amp;&amp; B[i] - B[d.getFirst()] &gt;=  K)
                res = Math.min(res, i - d.pollFirst());
            while (d.size() &gt; 0 &amp;&amp; B[i] &lt;= B[d.getLast()]) 
                d.pollLast();
            d.addLast(i);
        }
        return res &lt;= N ? res : -1;
    }
}
</code></pre>
<p><strong>901. Online Stock Span</strong></p>
<pre><code>class StockSpanner {

    public StockSpanner() {
        
    }
    
    Stack&lt;int[]&gt; stack = new Stack&lt;&gt;();
    public int next(int price) {
        int res = 1;
        while (!stack.isEmpty() &amp;&amp; stack.peek()[0] &lt;= price)
            res += stack.pop()[1];
        stack.push(new int[]{price, res});
        return res;
    }
}
</code></pre>
<p><strong>LC907. Sum of Subarray Minimums</strong></p>
<pre><code>class Solution {
    public int sumSubarrayMins(int[] A) {
        int MOD = 1_000_000_007;
        int N = A.length;

        // prev has i* - 1 in increasing order of A[i* - 1]
        // where i* is the answer to query j
        Stack&lt;Integer&gt; stack = new Stack();
        int[] prev = new int[N];
        for (int i = 0; i &lt; N; ++i) {
            while (!stack.isEmpty() &amp;&amp; A[i] &lt;= A[stack.peek()])
                stack.pop();
            prev[i] = stack.isEmpty() ? -1 : stack.peek();
            stack.push(i);
        }

        // next has k* + 1 in increasing order of A[k* + 1]
        // where k* is the answer to query j
        stack = new Stack();
        int[] next = new int[N];
        for (int k = N-1; k &gt;= 0; --k) {
            while (!stack.isEmpty() &amp;&amp; A[k] &lt; A[stack.peek()])
                stack.pop();
            next[k] = stack.isEmpty() ? N : stack.peek();
            stack.push(k);
        }

        // Use prev/next array to count answer
        long ans = 0;
        for (int i = 0; i &lt; N; ++i) {
            ans += (i - prev[i]) * (next[i] - i) % MOD * A[i] % MOD;
            ans %= MOD;
        }
        return (int) ans;

    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DP summary]]></title>
        <id>https://ywang412.github.io/post/dp-summary</id>
        <link href="https://ywang412.github.io/post/dp-summary">
        </link>
        <updated>2019-07-25T17:37:53.000Z</updated>
        <content type="html"><![CDATA[<p><strong>375. Guess Number Higher or Lower II</strong></p>
<pre><code>public class Solution {
    public int getMoneyAmount(int n) {
        if (n == 1) {
            return 0;
        }
        int[][] dp = new int[n + 1][n + 1];
        for (int jminusi = 1; jminusi &lt; n; jminusi++) {
            for (int i = 0; i + jminusi &lt;= n; i++) {
                int j = i + jminusi;
                dp[i][j] = Integer.MAX_VALUE;
                for (int k = i; k &lt;= j; k++) {
                    dp[i][j] = Math.min(dp[i][j],
                                        k + Math.max(k - 1 &gt;= i ? dp[i][k - 1] : 0,
                                                     j &gt;= k + 1 ? dp[k + 1][j] : 0));
                }
            }
        }
        return dp[1][n];
    }
}
</code></pre>
<p><strong>377. Best Time to Buy and Sell Stock IV</strong></p>
<pre><code>class Solution {
    public int maxProfit(int k, int[] prices) {
        int len = prices.length;
        if (k &gt;= len / 2) return quickSolve(prices);
        
        int[][] t = new int[k + 1][len];
        for (int i = 1; i &lt;= k; i++) {
            int tmpMax =  -prices[0];  // tmpMax is the max after i-1th transaction and 1 more sell. 
            for (int j = 1; j &lt; len; j++) {
                t[i][j] = Math.max(t[i][j - 1], prices[j] + tmpMax);
                tmpMax =  Math.max(tmpMax, t[i - 1][j - 1] - prices[j]);
            }
        }
        return t[k][len - 1];
    }
    

    private int quickSolve(int[] prices) {
        int len = prices.length, profit = 0;
        for (int i = 1; i &lt; len; i++)
            // as long as there is a price gap, we gain a profit.
            if (prices[i] &gt; prices[i - 1]) profit += prices[i] - prices[i - 1];
        return profit;
    }
}
</code></pre>
<p><strong>Coin in a line</strong>
F(i, j)  represents the maximum value the user can collect from
i'th coin to j'th coin.</p>
<pre><code>F(i, j)  = Max(Vi + min(F(i+2, j), F(i+1, j-1) ), 
               Vj + min(F(i+1, j-1), F(i, j-2) )) 
</code></pre>
<p>Base Cases
F(i, j)  = Vi           If j == i
F(i, j)  = max(Vi, Vj)  If j == i+1</p>
<pre><code>static int optimalStrategyOfGame(int arr[], int n) 
{ 
		// Create a table to store solutions of subproblems 
		int table[][] = new int[n][n]; 
		int gap, i, j, x, y, z; 

		// Fill table using above recursive formula. 
		// Note that the tableis filled in diagonal 
		// fashion (similar to http:// goo.gl/PQqoS), 
		// from diagonal elements to table[0][n-1] 
		// which is the result. 
		for (gap = 0; gap &lt; n; ++gap) { 
				for (i = 0, j = gap; j &lt; n; ++i, ++j) { 

						// Here x is value of F(i+2, j), 
						// y is F(i+1, j-1) and z is 
						// F(i, j-2) in above recursive formula 
						x = ((i + 2) &lt;= j) ? table[i + 2][j] : 0; 
						y = ((i + 1) &lt;= (j - 1)) ? table[i + 1][j - 1] : 0; 
						z = (i &lt;= (j - 2)) ? table[i][j - 2] : 0; 

						table[i][j] = Math.max(arr[i] + Math.min(x, y),  
																	 arr[j] + Math.min(y, z)); 
				} 
		} 

		return table[0][n - 1]; 
}
</code></pre>
<p><strong>Maximum size square sub-matrix with all 1s</strong></p>
<p><img src="https://ywang412.github.io/post-images/1566875991890.png" alt=""></p>
<ol>
<li>Construct a sum matrix S[R][C] for the given M[R][C].
a)    Copy first row and first columns as it is from M[][] to S[][]
b)    For other entries, use following expressions to construct S[][]
If M[i][j] is 1 then
S[i][j] = min(S[i][j-1], S[i-1][j], S[i-1][j-1]) + 1
Else /<em>If M[i][j] is 0</em>/
S[i][j] = 0</li>
<li>Find the maximum entry in S[R][C]</li>
<li>Using the value and coordinates of maximum entry in S[i], print
sub-matrix of M[][]</li>
</ol>
<pre><code>static void printMaxSubSquare(int M[][]) 
    { 
        int i,j; 
        int R = M.length;         //no of rows in M[][] 
        int C = M[0].length;     //no of columns in M[][] 
        int S[][] = new int[R][C];      
          
        int max_of_s, max_i, max_j;  
      
        /* Set first column of S[][]*/
        for(i = 0; i &lt; R; i++) 
            S[i][0] = M[i][0]; 
      
        /* Set first row of S[][]*/
        for(j = 0; j &lt; C; j++) 
            S[0][j] = M[0][j]; 
          
        /* Construct other entries of S[][]*/
        for(i = 1; i &lt; R; i++) 
        { 
            for(j = 1; j &lt; C; j++) 
            { 
                if(M[i][j] == 1)  
                    S[i][j] = Math.min(S[i][j-1], 
                                Math.min(S[i-1][j], S[i-1][j-1])) + 1; 
                else
                    S[i][j] = 0; 
            }  
        }      
          
        /* Find the maximum entry, and indexes of maximum entry  
            in S[][] */
        max_of_s = S[0][0]; max_i = 0; max_j = 0; 
        for(i = 0; i &lt; R; i++) 
        { 
            for(j = 0; j &lt; C; j++) 
            { 
                if(max_of_s &lt; S[i][j]) 
                { 
                    max_of_s = S[i][j]; 
                    max_i = i;  
                    max_j = j; 
                }      
            }                  
        }      
          
        System.out.println(&quot;Maximum size sub-matrix is: &quot;); 
        for(i = max_i; i &gt; max_i - max_of_s; i--) 
        { 
            for(j = max_j; j &gt; max_j - max_of_s; j--) 
            { 
                System.out.print(M[i][j] + &quot; &quot;); 
            }  
            System.out.println(); 
        }  
    }
</code></pre>
<p><strong>0-1 Knapsack Problem</strong></p>
<p>/* A Naive recursive implementation of 0-1 Knapsack problem */</p>
<pre><code>static int knapSack(int W, int wt[], int val[], int n) 
{ 
	// Base Case 
if (n == 0 || W == 0) 
	return 0; 

// If weight of the nth item is more than Knapsack capacity W, then 
// this item cannot be included in the optimal solution 
if (wt[n-1] &gt; W) 
 return knapSack(W, wt, val, n-1); 

// Return the maximum of two cases:  
// (1) nth item included  
// (2) not included 
else return max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1), 
							 knapSack(W, wt, val, n-1) 
								); 
} 
</code></pre>
<pre><code>static int knapSack(int W, int wt[], int val[], int n) 
{ 
	 int i, w; 
int K[][] = new int[n+1][W+1]; 

// Build table K[][] in bottom up manner 
for (i = 0; i &lt;= n; i++) 
{ 
	 for (w = 0; w &lt;= W; w++) 
	 { 
			 if (i==0 || w==0) 
						K[i][w] = 0; 
			 else if (wt[i-1] &lt;= w) 
						 K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]],  K[i-1][w]); 
			 else
						 K[i][w] = K[i-1][w]; 
	 } 
} 

return K[n][W]; 
} 
</code></pre>
<p><strong>518. Coin Change 2</strong></p>
<pre><code>class Solution {
    public int change(int amount, int[] coins) {
        int[][] dp = new int[coins.length+1][amount+1]; 
        
        for (int i = 0; i &lt;= coins.length; i++) {
            dp[i][0] = 1;        
        }
        
        for (int i = 1; i &lt;= coins.length; i++) {
            for (int j = 1; j &lt;= amount; j++) {
                dp[i][j] = dp[i-1][j] + (j &gt;= coins[i-1] ? dp[i][j-coins[i-1]] : 0);
            }
        }
        return dp[coins.length][amount];
    }
}
</code></pre>
<p><strong>416. Partition Equal Subset Sum</strong></p>
<pre><code>class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for(int num: nums) sum += num;
        if(sum % 2 == 1) return false;
        
        int target = sum / 2;
        boolean[][] dp = new boolean[nums.length][target + 1];
        // deal with the first row
        if(nums[0] &lt;= target) dp[0][nums[0]] = true;
        
        // deal with the first col
        for(int i = 0; i &lt; nums.length; i++) dp[i][0] = true;
        
        // deal with the rest
        for(int i = 1; i &lt; nums.length; i++) {
            for(int j = 1; j &lt; target + 1; j++) {
                if(j &lt; nums[i]) {
                    dp[i][j] = dp[i - 1][j];
                } else {
                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];
                }
            }
        }
        return dp[nums.length - 1][target];
    }
}
</code></pre>
<p><strong>920. Number of Music Playlists</strong></p>
<pre><code>class Solution {
    public int numMusicPlaylists(int N, int L, int K) {
        int MOD = 1_000_000_007;

        long[][] dp = new long[L+1][N+1];
        dp[0][0] = 1;
        for (int i = 1; i &lt;= L; ++i)
            for (int j = 1; j &lt;= N; ++j) {
                dp[i][j] += dp[i-1][j-1] * (N-j+1);
                dp[i][j] += dp[i-1][j] * Math.max(j-K, 0);
                dp[i][j] %= MOD;
            }

        return (int) dp[L][N];
    }
}
</code></pre>
<p><strong>Edit Distance</strong></p>
<pre><code>static int editDistDP(String str1, String str2, int m, int n) 
{ 
		// Create a table to store results of subproblems 
		int dp[][] = new int[m+1][n+1]; 

		// Fill d[][] in bottom up manner 
		for (int i=0; i&lt;=m; i++) 
		{ 
				for (int j=0; j&lt;=n; j++) 
				{ 
						// If first string is empty, only option is to 
						// insert all characters of second string 
						if (i==0) 
								dp[i][j] = j;  // Min. operations = j 

						// If second string is empty, only option is to 
						// remove all characters of second string 
						else if (j==0) 
								dp[i][j] = i; // Min. operations = i 

						// If last characters are same, ignore last char 
						// and recur for remaining string 
						else if (str1.charAt(i-1) == str2.charAt(j-1)) 
								dp[i][j] = dp[i-1][j-1]; 

						// If the last character is different, consider all 
						// possibilities and find the minimum 
						else
								dp[i][j] = 1 + min(dp[i][j-1],  // Insert 
																	 dp[i-1][j],  // Remove 
																	 dp[i-1][j-1]); // Replace 
				} 
		} 

		return dp[m][n]; 
} 
</code></pre>
<p><strong>516. Longest Palindromic Subsequence</strong></p>
<pre><code>class Solution {
    public int longestPalindromeSubseq(String s) {
        int m = s.length();
        int[][] dp = new int[m][m];
        for (int i = 0; i &lt; m; i++) {
            dp[i][i] = 1;
        }
        
        for (int len = 2; len &lt;= m; len++) {
            for (int i = 0; i &lt;= m - len; i++) {
                if (s.charAt(i) == s.charAt(i + len -1)) {
                    dp[i][i + len - 1] = dp[i + 1][i + len - 2] + 2;
                }
                else {
                    dp[i][i + len - 1] = Math.max(dp[i + 1][i + len -1], dp[i][i + len - 2]);
                }
            }
        }
        return dp[0][m - 1];
    }
}
</code></pre>
<p><strong>975. Odd Even Jump</strong></p>
<pre><code>class Solution {
    public int oddEvenJumps(int[] A) {
        int n  = A.length, res = 1;
        boolean[] higher = new boolean[n], lower = new boolean[n];
        higher[n - 1] = lower[n - 1] = true;
        TreeMap&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;();
        map.put(A[n - 1], n - 1);
        for (int i = n - 2; i &gt;= 0; --i) {
            Map.Entry hi = map.ceilingEntry(A[i]), lo = map.floorEntry(A[i]);
            if (hi != null) higher[i] = lower[(int)hi.getValue()];
            if (lo != null) lower[i] = higher[(int)lo.getValue()];
            if (higher[i]) res++;
            map.put(A[i], i);
        }
        return res;
    }
}
</code></pre>
<p><strong>10. Regular Expression Matching</strong></p>
<p>'.' Matches any single character.
'*' Matches zero or more of the preceding element.</p>
<pre><code>class Solution {
    public boolean isMatch(String s, String p) {
        if (s == null || p == null) return false;
        boolean[][] dp = new boolean[s.length()+1][p.length()+1];
        dp[0][0] = true;
        
        for (int j = 0; j &lt; p.length(); j++) {
            if (p.charAt(j) == '*') {
                dp[0][j+1] = dp[0][j-1];      
            } 
        }
        
        for (int i = 0; i &lt; s.length(); i++) {
            for (int j = 0; j &lt; p.length(); j++) {
                if (p.charAt(j) == s.charAt(i) || p.charAt(j) == '.') {
                    dp[i+1][j+1] = dp[i][j];     // dp[i+1][j+1]  is match until i and j (i+1, j+1 exclusive)
                }
                if (p.charAt(j) == '*') {
                    if (p.charAt(j-1) != s.charAt(i) &amp;&amp; p.charAt(j-1) != '.') {
                        dp[i+1][j+1] = dp[i+1][j-1];
                    }
                    else { // * only counts as non-zero, then `a*` can be treated as `a*a`!!!  a*a means  dp[i+1][j+1] = (dp[i][j+1])  the last char in s is gone
                        dp[i+1][j+1] = (dp[i][j+1] || dp[i+1][j-1] || dp[i+1][j]);
                    }
                }
            }
        }  
        return dp[s.length()][p.length()];
    }
}
</code></pre>
<p><strong>44. Wildcard Matching</strong></p>
<p>'?' Matches any single character.
'*' Matches any sequence of characters (including the empty sequence).</p>
<pre><code>class Solution {
    public boolean isMatch(String s, String p) {
        int m=s.length(), n=p.length();
        boolean[][] dp = new boolean[m+1][n+1];
        dp[0][0] = true;
        for (int i=1; i&lt;=m; i++) {
            dp[i][0] = false;
        }

        for(int j=1; j&lt;=n; j++) {
            if(p.charAt(j-1)=='*'){
                dp[0][j] = true;
            } else {
                break;
            }
        }

        for(int i=1; i&lt;=m; i++) {
            for(int j=1; j&lt;=n; j++) {
                if (s.charAt(i-1)==p.charAt(j-1) || p.charAt(j-1)=='?')  {
                    dp[i][j] = dp[i-1][j-1];
                } else if (p.charAt(j-1) == '*'){
                    dp[i][j] = dp[i-1][j] || dp[i][j-1];
                }
            }
        }
        return dp[m][n];
        }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Quick sort, quick select, merge sort, bucket sort, bubble sort and topological sort]]></title>
        <id>https://ywang412.github.io/post/quick-sort-quick-select-and-merge-sort</id>
        <link href="https://ywang412.github.io/post/quick-sort-quick-select-and-merge-sort">
        </link>
        <updated>2019-07-25T07:09:43.000Z</updated>
        <content type="html"><![CDATA[<p><strong>215. Kth Largest Element in an Array</strong></p>
<pre><code>class Solution {
    public int findKthLargest(int[] nums, int k) {
        return quickSelectK(nums, 0, nums.length - 1, nums.length - k);
    }
    
    public int quickSelectK(int[] nums, int start, int end, int k) { 
        
        int pivot = nums[start];
        int i = start;
        int j = end;
        while (i &lt; j) { 
            while (i &lt; end &amp;&amp; nums[i] &lt;= pivot) i++;
            while (j &gt; start &amp;&amp; nums[j] &gt;= pivot) j--; 
            if (i &lt; j) {
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
            }   
        } 
        nums[start] = nums[j];
        nums[j] = pivot;
        if (j == k) return nums[j];
        else if (j &lt; k) return quickSelectK(nums, j + 1, end, k);
        else return quickSelectK(nums, start, j, k);
    } 
}
</code></pre>
<p><strong>Bucket Sort</strong></p>
<pre><code>private static void bucketSort(int[] intArr, int noOfBuckets){
		// Create bucket array
		List&lt;Integer&gt;[] buckets = new List[noOfBuckets];
		// Associate a list with each index 
		// in the bucket array         
		for(int i = 0; i &lt; noOfBuckets; i++){
				buckets[i] = new LinkedList&lt;&gt;();
		}
		// Assign numbers from array to the proper bucket
		// by using hashing function
		for(int num : intArr){
				//System.out.println(&quot;hash- &quot; + hash(num));
				buckets[hash(num)].add(num);
		}
		// sort buckets
		for(List&lt;Integer&gt; bucket : buckets){
				Collections.sort(bucket);
		}
		int i = 0;
		// Merge buckets to get sorted array
		for(List&lt;Integer&gt; bucket : buckets){
				for(int num : bucket){
						intArr[i++] = num;
				}
		}
}
</code></pre>
<p><strong>Topological Sort</strong>
Course Schedule II</p>
<pre><code>public int[] findOrder(int numCourses, int[][] prerequisites) {
        
    boolean isPossible = true;
    Map&lt;Integer, List&lt;Integer&gt;&gt; adjList = new HashMap&lt;Integer, List&lt;Integer&gt;&gt;();
    int[] indegree = new int[numCourses];
    int[] topologicalOrder = new int[numCourses];

    // Create the adjacency list representation of the graph
    for (int i = 0; i &lt; prerequisites.length; i++) {
      int dest = prerequisites[i][0];
      int src = prerequisites[i][1];
      List&lt;Integer&gt; lst = adjList.getOrDefault(src, new ArrayList&lt;Integer&gt;());
      lst.add(dest);
      adjList.put(src, lst);

      // Record in-degree of each vertex
      indegree[dest] += 1;
    }

    // Add all vertices with 0 in-degree to the queue
    Queue&lt;Integer&gt; q = new LinkedList&lt;Integer&gt;();
    for (int i = 0; i &lt; numCourses; i++) {
      if (indegree[i] == 0) {
        q.add(i);
      }
    }

    int i = 0;
    // Process until the Q becomes empty
    while (!q.isEmpty()) {
      int node = q.remove();
      topologicalOrder[i++] = node;

      // Reduce the in-degree of each neighbor by 1
      if (adjList.containsKey(node)) {
        for (Integer neighbor : adjList.get(node)) {
          indegree[neighbor]--;

          // If in-degree of a neighbor becomes 0, add it to the Q
          if (indegree[neighbor] == 0) {
            q.add(neighbor);
          }
        }
      }
    }

    // Check to see if topological sort is possible or not.
    if (i == numCourses) {
      return topologicalOrder;
    }

    return new int[0];
  } 
</code></pre>
<p>Topological sort using DFS</p>
<pre><code>// A recursive function used by topologicalSort 
void topologicalSortUtil(int v, boolean visited[], 
												 Stack stack) 
{ 
		// Mark the current node as visited. 
		visited[v] = true; 
		Integer i; 

		// Recur for all the vertices adjacent to this 
		// vertex 
		Iterator&lt;Integer&gt; it = adj[v].iterator(); 
		while (it.hasNext()) 
		{ 
				i = it.next(); 
				if (!visited[i]) 
						topologicalSortUtil(i, visited, stack); 
		} 

		// Push current vertex to stack which stores result 
		stack.push(new Integer(v)); 
} 

// The function to do Topological Sort. It uses 
// recursive topologicalSortUtil() 
void topologicalSort() 
{ 
		Stack stack = new Stack(); 

		// Mark all the vertices as not visited 
		boolean visited[] = new boolean[V]; 
		for (int i = 0; i &lt; V; i++) 
				visited[i] = false; 

		// Call the recursive helper function to store 
		// Topological Sort starting from all vertices 
		// one by one 
		for (int i = 0; i &lt; V; i++) 
				if (visited[i] == false) 
						topologicalSortUtil(i, visited, stack); 

		// Print contents of stack 
		while (stack.empty()==false) 
				System.out.print(stack.pop() + &quot; &quot;); 
} 
</code></pre>
<p><strong>Bubble sort</strong></p>
<pre><code>void bubbleSort(int arr[]) 
{ 
		int n = arr.length; 
		for (int i = 0; i &lt; n-1; i++) 
				for (int j = 0; j &lt; n-i-1; j++) 
						if (arr[j] &gt; arr[j+1]) 
						{ 
								// swap arr[j+1] and arr[i] 
								int temp = arr[j]; 
								arr[j] = arr[j+1]; 
								arr[j+1] = temp; 
						} 
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java JUC (java.util.concurrent) 5 - ThreadPool and ThreadLocal]]></title>
        <id>https://ywang412.github.io/post/java-juc-javautilconcurrent-5-threadpool-and-threadlocal</id>
        <link href="https://ywang412.github.io/post/java-juc-javautilconcurrent-5-threadpool-and-threadlocal">
        </link>
        <updated>2019-07-07T01:19:02.000Z</updated>
        <content type="html"><![CDATA[<p>Java use Thread Pool pattern to save resources in a multithreaded application, and also to contain the parallelism in certain predefined limits. It controls several re-used threads for executing these tasks.</p>
<pre><code>ExecutorService executorService = Executors.newCachedThreadPool();
for (int i = 0; i &lt; 10; i++) {
		final int index = i;
		executorService.execute(new Runnable() {
				@Override
				public void run() {
						log.info(&quot;task:{}&quot;, index);
				}
		});
}
executorService.shutdown();
</code></pre>
<p>There are several pre-defined threadpool for various scenarios.</p>
<pre><code>ExecutorService executorService = Executors.newFixedThreadPool(3);
ExecutorService executorService = Executors.newSingleThreadExecutor();
ScheduledExecutorService executorService = Executors.newScheduledThreadPool(1);
</code></pre>
<p>The TheadLocal construct allows us to store data that will be accessible only by a specific thread.</p>
<pre><code>private final static ThreadLocal&lt;Long&gt; requestHolder = new ThreadLocal&lt;&gt;();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java JUC (java.util.concurrent) 4 - Lock]]></title>
        <id>https://ywang412.github.io/post/java-juc-javautilconcurrent-2-lock</id>
        <link href="https://ywang412.github.io/post/java-juc-javautilconcurrent-2-lock">
        </link>
        <updated>2019-07-03T17:07:58.000Z</updated>
        <content type="html"><![CDATA[<p>Compare to <code>synchronized</code> keyword, Locks support various methods for finer grained control thus are more expressive than <code>synchronized</code>.</p>
<p>Since <code>synchronized</code> keyword create lock implicitly, one can convert the  <code>synchronized</code> keyword to ReentrantLock.</p>
<pre><code>private synchronized static void add() {
        count++;
}
</code></pre>
<pre><code>private final static Lock lock = new ReentrantLock();
private static void add() {
		lock.lock();
		try {
				count++;
		} finally {
				lock.unlock();
		}
}
</code></pre>
<p>Therefore, it is possible for both <code>synchronized</code> and Lock to introduce the well-know deadlock problem like below.</p>
<pre><code>public class DeadLock implements Runnable {
    public int flag = 1;
    //静态对象是类的所有对象共享的
    private static Object o1 = new Object(), o2 = new Object();

    @Override
    public void run() {
        log.info(&quot;flag:{}&quot;, flag);
        if (flag == 1) {
            synchronized (o1) {
                try {
                    Thread.sleep(500);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                synchronized (o2) {
                    log.info(&quot;1&quot;);
                }
            }
        }
        if (flag == 0) {
            synchronized (o2) {
                try {
                    Thread.sleep(500);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                synchronized (o1) {
                    log.info(&quot;0&quot;);
                }
            }
        }
    }

    public static void main(String[] args) {
        DeadLock td1 = new DeadLock();
        DeadLock td2 = new DeadLock();
        td1.flag = 1;
        td2.flag = 0;
        //td1,td2都处于可执行状态，但JVM线程调度先执行哪个线程是不确定的。
        //td2的run()可能在td1的run()之前运行
        new Thread(td1).start();
        new Thread(td2).start();
    }
}
</code></pre>
<p>The <code>synchronized</code> keyword provides a simplified model while Lock offers more APIs such as ReentrantReadWriteLock and Condition. The interface ReadWriteLock specifies a pair of locks for read and write access. This can improve performance and throughput in cases where write-accesses are much less frequent.</p>
<pre><code>private final Map&lt;String, Data&gt; map = new TreeMap&lt;&gt;();

private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
private final Lock readLock = lock.readLock();
private final Lock writeLock = lock.writeLock();

public Data get(String key) {
		readLock.lock();
		try {
				return map.get(key);
		} finally {
				readLock.unlock();
		}
}

public Data put(String key, Data value) {
		writeLock.lock();
		try {
				return map.put(key, value);
		} finally {
				writeLock.unlock();
		}
}
</code></pre>
<p><code>Condition.signalAll()</code> is a very important API in consumer-producer model.</p>
<pre><code>public static void main(String[] args) {
		ReentrantLock reentrantLock = new ReentrantLock();
		Condition condition = reentrantLock.newCondition();

		new Thread(() -&gt; {
				try {
						reentrantLock.lock();
						log.info(&quot;wait signal&quot;); // 1
						condition.await();
				} catch (InterruptedException e) {
						e.printStackTrace();
				}
				log.info(&quot;get signal&quot;); // 4
				reentrantLock.unlock();
		}).start();

		new Thread(() -&gt; {
				reentrantLock.lock();
				log.info(&quot;get lock&quot;); // 2
				try {
						Thread.sleep(3000);
				} catch (InterruptedException e) {
						e.printStackTrace();
				}
				condition.signalAll();
				log.info(&quot;send signal ~ &quot;); // 3
				reentrantLock.unlock();
		}).start();
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Contributing to Scala zio, a github open source project]]></title>
        <id>https://ywang412.github.io/post/contributing-to-a-scala-zio-a-github-open-source-project</id>
        <link href="https://ywang412.github.io/post/contributing-to-a-scala-zio-a-github-open-source-project">
        </link>
        <updated>2019-06-23T04:54:56.000Z</updated>
        <content type="html"><![CDATA[<p>I've hoped to contribute to open source project on github to be a part of the open source community and become a better developer. Today my two pull requests to a high profile scala repository, zio, got approved and I am very excited. The friendly and encouraging github community brought me a great experience.</p>
<p>These are the two pull requests that I made.</p>
<p>https://github.com/zio/zio/pull/1109
and
https://github.com/zio/zio/pull/1106</p>
<p>The first one is to deprecate a FiberLocal class.
<img src="https://ywang412.github.io/post-images/1561874927019.png" alt="">
The second one is to fix a bug resulting from different Windows/Linux file seperator.
<img src="https://ywang412.github.io/post-images/1561874992932.png" alt=""></p>
<p>The zio scala repository is very well maintained with decent test coverage and CD/CI pipeline. Thanks to the project maintainers for their huge efforts.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java JUC (java.util.concurrent) 3 - Synchronized and Synchronized Container]]></title>
        <id>https://ywang412.github.io/post/java-juc-javautilconcurrent-3-synchronzied-and-synchronzied-container</id>
        <link href="https://ywang412.github.io/post/java-juc-javautilconcurrent-3-synchronzied-and-synchronzied-container">
        </link>
        <updated>2019-05-14T11:31:10.000Z</updated>
        <content type="html"><![CDATA[<p><code>Synchronized</code> keyword bounds monitor to an object and has made concurrency programing simple. It can be added to method or object to achieve object level synchronization. It can also modify static method or class for class level synchronization.</p>
<pre><code>// 修饰一个代码块
public void test1(int j) {
		synchronized (this) {
				for (int i = 0; i &lt; 10; i++) {
						log.info(&quot;test1 {} - {}&quot;, j, i);
				}
		}
}

// 修饰一个方法
public synchronized void test2(int j) {
		for (int i = 0; i &lt; 10; i++) {
				log.info(&quot;test2 {} - {}&quot;, j, i);
		}
}

public static void main(String[] args) {
		SynchronizedExample1 example1 = new SynchronizedExample1();
		SynchronizedExample1 example2 = new SynchronizedExample1();
		ExecutorService executorService = Executors.newCachedThreadPool();
		executorService.execute(() -&gt; {
				example1.test2(1);
		});
		executorService.execute(() -&gt; {
				example2.test2(2);
		});
}
</code></pre>
<pre><code>// 修饰一个类
public static void test1(int j) {
		synchronized (SynchronizedExample2.class) {
				for (int i = 0; i &lt; 10; i++) {
						log.info(&quot;test1 {} - {}&quot;, j, i);
				}
		}
}

// 修饰一个静态方法
public static synchronized void test2(int j) {
		for (int i = 0; i &lt; 10; i++) {
				log.info(&quot;test2 {} - {}&quot;, j, i);
		}
}

public static void main(String[] args) {
		SynchronizedExample2 example1 = new SynchronizedExample2();
		SynchronizedExample2 example2 = new SynchronizedExample2();
		ExecutorService executorService = Executors.newCachedThreadPool();
		executorService.execute(() -&gt; {
				example1.test1(1);
		});
		executorService.execute(() -&gt; {
				example2.test1(2);
		});
}
</code></pre>
<p>Java provide several thread safe synchronized containers out of the box.</p>
<pre><code>private static List&lt;Integer&gt; list = Collections.synchronizedList(Lists.newArrayList());
private static Set&lt;Integer&gt; set = Collections.synchronizedSet(Sets.newHashSet());
private static Map&lt;Integer, Integer&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;());
private static Map&lt;Integer, Integer&gt; map = new Hashtable&lt;&gt;();
private static List&lt;Integer&gt; list = new Vector&lt;&gt;();
</code></pre>
<p>Java and Guava also provide several immutable containers out of the box.</p>
<pre><code>private static Map&lt;Integer, Integer&gt; map = Maps.newHashMap();
static {
		map.put(1, 2);
		map.put(3, 4);
		map.put(5, 6);
		map = Collections.unmodifiableMap(map);
}
</code></pre>
<pre><code>import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
private final static ImmutableList&lt;Integer&gt; list = ImmutableList.of(1, 2, 3);
private final static ImmutableSet set = ImmutableSet.copyOf(list);
private final static ImmutableMap&lt;Integer, Integer&gt; map = ImmutableMap.of(1, 2, 3, 4);
private final static ImmutableMap&lt;Integer, Integer&gt; map2 = ImmutableMap.&lt;Integer, Integer&gt;builder()
				.put(1, 2).put(3, 4).put(5, 6).build();
</code></pre>
]]></content>
    </entry>
</feed>