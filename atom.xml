<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ywang412.github.io</id>
    <title>Yu&apos;s Github</title>
    <updated>2019-07-08T03:27:23.069Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ywang412.github.io"/>
    <link rel="self" href="https://ywang412.github.io/atom.xml"/>
    <subtitle>Java by day, Scala by night</subtitle>
    <logo>https://ywang412.github.io/images/avatar.png</logo>
    <icon>https://ywang412.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Yu&apos;s Github</rights>
    <entry>
        <title type="html"><![CDATA[Java JUC (java.util.concurrent) 5 - ThreadPool and ThreadLocal]]></title>
        <id>https://ywang412.github.io/post/java-juc-javautilconcurrent-5-threadpool-and-threadlocal</id>
        <link href="https://ywang412.github.io/post/java-juc-javautilconcurrent-5-threadpool-and-threadlocal">
        </link>
        <updated>2019-07-07T01:19:02.000Z</updated>
        <content type="html"><![CDATA[<p>Java use Thread Pool pattern to save resources in a multithreaded application, and also to contain the parallelism in certain predefined limits. It controls several re-used threads for executing these tasks.</p>
<pre><code>ExecutorService executorService = Executors.newCachedThreadPool();
for (int i = 0; i &lt; 10; i++) {
		final int index = i;
		executorService.execute(new Runnable() {
				@Override
				public void run() {
						log.info(&quot;task:{}&quot;, index);
				}
		});
}
executorService.shutdown();
</code></pre>
<p>There are several pre-defined threadpool for various scenarios.</p>
<pre><code>ExecutorService executorService = Executors.newFixedThreadPool(3);
ExecutorService executorService = Executors.newSingleThreadExecutor();
ScheduledExecutorService executorService = Executors.newScheduledThreadPool(1);
</code></pre>
<p>The TheadLocal construct allows us to store data that will be accessible only by a specific thread.</p>
<pre><code>private final static ThreadLocal&lt;Long&gt; requestHolder = new ThreadLocal&lt;&gt;();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java JUC (java.util.concurrent) 4 - Lock]]></title>
        <id>https://ywang412.github.io/post/java-juc-javautilconcurrent-2-lock</id>
        <link href="https://ywang412.github.io/post/java-juc-javautilconcurrent-2-lock">
        </link>
        <updated>2019-07-06T06:07:58.000Z</updated>
        <content type="html"><![CDATA[<p>Compare to <code>synchronized</code> keyword, Locks support various methods for finer grained control thus are more expressive than <code>synchronized</code>.</p>
<p>Since <code>synchronized</code> keyword create lock implicitly, one can convert the  <code>synchronized</code> keyword to ReentrantLock.</p>
<pre><code>private synchronized static void add() {
        count++;
}
</code></pre>
<pre><code>private final static Lock lock = new ReentrantLock();
private static void add() {
		lock.lock();
		try {
				count++;
		} finally {
				lock.unlock();
		}
}
</code></pre>
<p>Therefore, it is possible for both <code>synchronized</code> and Lock to introduce the well-know deadlock problem like below.</p>
<pre><code>public class DeadLock implements Runnable {
    public int flag = 1;
    //静态对象是类的所有对象共享的
    private static Object o1 = new Object(), o2 = new Object();

    @Override
    public void run() {
        log.info(&quot;flag:{}&quot;, flag);
        if (flag == 1) {
            synchronized (o1) {
                try {
                    Thread.sleep(500);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                synchronized (o2) {
                    log.info(&quot;1&quot;);
                }
            }
        }
        if (flag == 0) {
            synchronized (o2) {
                try {
                    Thread.sleep(500);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                synchronized (o1) {
                    log.info(&quot;0&quot;);
                }
            }
        }
    }

    public static void main(String[] args) {
        DeadLock td1 = new DeadLock();
        DeadLock td2 = new DeadLock();
        td1.flag = 1;
        td2.flag = 0;
        //td1,td2都处于可执行状态，但JVM线程调度先执行哪个线程是不确定的。
        //td2的run()可能在td1的run()之前运行
        new Thread(td1).start();
        new Thread(td2).start();
    }
}
</code></pre>
<p>The <code>synchronized</code> keyword provides a simplified model while Lock offers more APIs such as ReentrantReadWriteLock and Condition. The interface ReadWriteLock specifies a pair of locks for read and write access. This can improve performance and throughput in cases where write-accesses are much less frequent.</p>
<pre><code>private final Map&lt;String, Data&gt; map = new TreeMap&lt;&gt;();

private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
private final Lock readLock = lock.readLock();
private final Lock writeLock = lock.writeLock();

public Data get(String key) {
		readLock.lock();
		try {
				return map.get(key);
		} finally {
				readLock.unlock();
		}
}

public Data put(String key, Data value) {
		writeLock.lock();
		try {
				return map.put(key, value);
		} finally {
				writeLock.unlock();
		}
}
</code></pre>
<p><code>Condition.signalAll()</code> is a very important API in consumer-producer model.</p>
<pre><code>public static void main(String[] args) {
		ReentrantLock reentrantLock = new ReentrantLock();
		Condition condition = reentrantLock.newCondition();

		new Thread(() -&gt; {
				try {
						reentrantLock.lock();
						log.info(&quot;wait signal&quot;); // 1
						condition.await();
				} catch (InterruptedException e) {
						e.printStackTrace();
				}
				log.info(&quot;get signal&quot;); // 4
				reentrantLock.unlock();
		}).start();

		new Thread(() -&gt; {
				reentrantLock.lock();
				log.info(&quot;get lock&quot;); // 2
				try {
						Thread.sleep(3000);
				} catch (InterruptedException e) {
						e.printStackTrace();
				}
				condition.signalAll();
				log.info(&quot;send signal ~ &quot;); // 3
				reentrantLock.unlock();
		}).start();
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java JUC (java.util.concurrent) 2 - Atomic Variables and Concurrent Collection]]></title>
        <id>https://ywang412.github.io/post/java-juc-javautilconcurrent-2-atomic-variables</id>
        <link href="https://ywang412.github.io/post/java-juc-javautilconcurrent-2-atomic-variables">
        </link>
        <updated>2019-07-04T14:22:48.000Z</updated>
        <content type="html"><![CDATA[<p>Atomic varaibles are important parts of java concurrency API. It allows multiple threads safely access the same variables. The java.util.concurrent.atomic classes heavily used compare-and-swap (CAS) technique. CAS happens at CPU instruction level and is much more light weighted than synchronizing through locks or <code>synchronized</code> key word.</p>
<p>AtomicInteger, AtomicLong, LongAdder, AtomicBoolean, and AtomicReference<Integer> are some of the most used Atomic classes.</p>
<p><strong>AtomicInteger</strong></p>
<pre><code>// 请求总数
public static int clientTotal = 5000;
// 同时并发执行的线程数
public static int threadTotal = 200;
public static AtomicInteger count = new AtomicInteger(0);

public static void main(String[] args) throws Exception {
		ExecutorService executorService = Executors.newCachedThreadPool();
		final Semaphore semaphore = new Semaphore(threadTotal);
		final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);
		for (int i = 0; i &lt; clientTotal ; i++) {
				executorService.execute(() -&gt; {
						try {
								semaphore.acquire();
								add();
								semaphore.release();
						} catch (Exception e) {
								log.error(&quot;exception&quot;, e);
						}
						countDownLatch.countDown();
				});
		}
		countDownLatch.await();
		executorService.shutdown();
		log.info(&quot;count:{}&quot;, count.get());
}

private static void add() {
		count.incrementAndGet();
		// count.getAndIncrement();
}
</code></pre>
<p>Another way to acheive correct counting result like above is <code>synchronized</code> keyword.</p>
<pre><code>// 请求总数
public static int clientTotal = 5000;
// 同时并发执行的线程数
public static int threadTotal = 200;
public static int count = 0;

public static void main(String[] args) throws Exception {
		ExecutorService executorService = Executors.newCachedThreadPool();
		final Semaphore semaphore = new Semaphore(threadTotal);
		final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);
		for (int i = 0; i &lt; clientTotal ; i++) {
				executorService.execute(() -&gt; {
						try {
								semaphore.acquire();
								add();
								semaphore.release();
						} catch (Exception e) {
								log.error(&quot;exception&quot;, e);
						}
						countDownLatch.countDown();
				});
		}
		countDownLatch.await();
		executorService.shutdown();
		log.info(&quot;count:{}&quot;, count);
}

private synchronized static void add() {
		count++;
}
</code></pre>
<p>However, volatile keyword as in <code>public static volatile int count = 0;</code> will not be able to ensure threadsafety to due CPU instruction reorder.</p>
<p>ConcurrentHashMap, ConcurrentSkipListMap, ConcurrentSkipListSet, CopyOnWriteArrayList, CopyOnWriteArraySet are some typical concurrency collection classes in Java 8.</p>
<p><strong>CopyOnWriteArrayList</strong></p>
<pre><code>// 请求总数
public static int clientTotal = 5000;
// 同时并发执行的线程数
public static int threadTotal = 200;
private static List&lt;Integer&gt; list = new CopyOnWriteArrayList&lt;&gt;();

public static void main(String[] args) throws Exception {
		ExecutorService executorService = Executors.newCachedThreadPool();
		final Semaphore semaphore = new Semaphore(threadTotal);
		final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);
		for (int i = 0; i &lt; clientTotal; i++) {
				final int count = i;
				executorService.execute(() -&gt; {
						try {
								semaphore.acquire();
								update(count);
								semaphore.release();
						} catch (Exception e) {
								log.error(&quot;exception&quot;, e);
						}
						countDownLatch.countDown();
				});
		}
		countDownLatch.await();
		executorService.shutdown();
		log.info(&quot;size:{}&quot;, list.size());
}

private static void update(int i) {
		list.add(i);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java JUC (java.util.concurrent) 1 - AQS：AbstractQueuedSynchronizer]]></title>
        <id>https://ywang412.github.io/post/java-juc-javautilconcurrent-1-aqsabstractqueuedsynchronizer</id>
        <link href="https://ywang412.github.io/post/java-juc-javautilconcurrent-1-aqsabstractqueuedsynchronizer">
        </link>
        <updated>2019-07-02T08:02:16.000Z</updated>
        <content type="html"><![CDATA[<p>AbstractQueuedSynchronizer lays the foundation of java JUC programming. Concurrency classes are extensively using Sync class which extends from AQS as shown below.</p>
<p><img src="https://ywang412.github.io/post-images/1562476011734.png" alt=""></p>
<p>Some example code snippets of CountDownLatch, CyclicBarrier, Semaphore, ForkJoinTask, and FutureTask are explained here.</p>
<p><strong>CountDownLatch</strong></p>
<pre><code>public static void main(String[] args) throws Exception {
		ExecutorService exec = Executors.newCachedThreadPool();
		final CountDownLatch countDownLatch = new CountDownLatch(threadCount);
		for (int i = 0; i &lt; threadCount; i++) {
				final int threadNum = i;
				exec.execute(() -&gt; {
						try {
								test(threadNum);
						} catch (Exception e) {
								log.error(&quot;exception&quot;, e);
						} finally {
								countDownLatch.countDown();
						}
				});
		}
		countDownLatch.await(10, TimeUnit.MILLISECONDS);
		log.info(&quot;finish&quot;);
		exec.shutdown();
}

private static void test(int threadNum) throws Exception {
		Thread.sleep(100);
		log.info(&quot;{}&quot;, threadNum);
}
</code></pre>
<p><strong>CyclicBarrier</strong></p>
<pre><code>private static CyclicBarrier barrier = new CyclicBarrier(5);

public static void main(String[] args) throws Exception {
		ExecutorService executor = Executors.newCachedThreadPool();
		for (int i = 0; i &lt; 10; i++) {
				final int threadNum = i;
				Thread.sleep(1000);
				executor.execute(() -&gt; {
						try {
								race(threadNum);
						} catch (Exception e) {
								log.error(&quot;exception&quot;, e);
						}
				});
		}
		executor.shutdown();
}

private static void race(int threadNum) throws Exception {
		Thread.sleep(1000);
		log.info(&quot;{} is ready&quot;, threadNum);
		barrier.await();
		log.info(&quot;{} continue&quot;, threadNum);
}
</code></pre>
<p><strong>Semaphore</strong></p>
<pre><code>ExecutorService exec = Executors.newCachedThreadPool();
final Semaphore semaphore = new Semaphore(3);

for (int i = 0; i &lt; threadCount; i++) {
		final int threadNum = i;
		exec.execute(() -&gt; {
				try {
						if (semaphore.tryAcquire(5000, TimeUnit.MILLISECONDS)) { // 尝试获取一个许可
								test(threadNum);
								semaphore.release(); // 释放一个许可
						}
				} catch (Exception e) {
						log.error(&quot;exception&quot;, e);
				}
		});
}
exec.shutdown();
}

private static void test(int threadNum) throws Exception {
log.info(&quot;{}&quot;, threadNum);
Thread.sleep(1000);
}
</code></pre>
<p><strong>ForkJoinTask</strong></p>
<pre><code>public class ForkJoinTaskExample extends RecursiveTask&lt;Integer&gt; {

    public static final int threshold = 2;
    private int start;
    private int end;

    public ForkJoinTaskExample(int start, int end) {
        this.start = start;
        this.end = end;
    }

    @Override
    protected Integer compute() {
        int sum = 0;

        //如果任务足够小就计算任务
        boolean canCompute = (end - start) &lt;= threshold;
        if (canCompute) {
            for (int i = start; i &lt;= end; i++) {
                sum += i;
            }
        } else {
            // 如果任务大于阈值，就分裂成两个子任务计算
            int middle = (start + end) / 2;
            ForkJoinTaskExample leftTask = new ForkJoinTaskExample(start, middle);
            ForkJoinTaskExample rightTask = new ForkJoinTaskExample(middle + 1, end);

            // 执行子任务
            leftTask.fork();
            rightTask.fork();

            // 等待任务执行结束合并其结果
            int leftResult = leftTask.join();
            int rightResult = rightTask.join();

            // 合并子任务
            sum = leftResult + rightResult;
        }
        return sum;
    }

    public static void main(String[] args) {
        ForkJoinPool forkjoinPool = new ForkJoinPool();

        //生成一个计算任务，计算1+2+3+4
        ForkJoinTaskExample task = new ForkJoinTaskExample(1, 100);

        //执行一个任务
        Future&lt;Integer&gt; result = forkjoinPool.submit(task);

        try {
            log.info(&quot;result:{}&quot;, result.get());
        } catch (Exception e) {
            log.error(&quot;exception&quot;, e);
        }
    }
}
</code></pre>
<p><strong>Future</strong></p>
<pre><code>static class MyCallable implements Callable&lt;String&gt; {

        @Override
        public String call() throws Exception {
            log.info(&quot;do something in callable&quot;);
            Thread.sleep(5000);
            return &quot;Done&quot;;
        }
    }

    public static void main(String[] args) throws Exception {
        ExecutorService executorService = Executors.newCachedThreadPool();
        Future&lt;String&gt; future = executorService.submit(new MyCallable());
        log.info(&quot;do something in main&quot;);
        Thread.sleep(1000);
        String result = future.get();
        log.info(&quot;result：{}&quot;, result);
    }
</code></pre>
<p><strong>FutureTask</strong></p>
<pre><code>public static void main(String[] args) throws Exception {
		FutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(new Callable&lt;String&gt;() {
				@Override
				public String call() throws Exception {
						log.info(&quot;do something in callable&quot;);
						Thread.sleep(5000);
						return &quot;Done&quot;;
				}
		});

		new Thread(futureTask).start();
		log.info(&quot;do something in main&quot;);
		Thread.sleep(1000);
		String result = futureTask.get();
		log.info(&quot;result：{}&quot;, result);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java JUC (java.util.concurrent) 3 - Synchronized and Synchronized Container]]></title>
        <id>https://ywang412.github.io/post/java-juc-javautilconcurrent-3-synchronzied-and-synchronzied-container</id>
        <link href="https://ywang412.github.io/post/java-juc-javautilconcurrent-3-synchronzied-and-synchronzied-container">
        </link>
        <updated>2019-07-02T00:31:10.000Z</updated>
        <content type="html"><![CDATA[<p><code>Synchronized</code> keyword bounds monitor to an object and has made concurrency programing simple. It can be added to method or object to achieve object level synchronization. It can also modify static method or class for class level synchronization.</p>
<pre><code>// 修饰一个代码块
public void test1(int j) {
		synchronized (this) {
				for (int i = 0; i &lt; 10; i++) {
						log.info(&quot;test1 {} - {}&quot;, j, i);
				}
		}
}

// 修饰一个方法
public synchronized void test2(int j) {
		for (int i = 0; i &lt; 10; i++) {
				log.info(&quot;test2 {} - {}&quot;, j, i);
		}
}

public static void main(String[] args) {
		SynchronizedExample1 example1 = new SynchronizedExample1();
		SynchronizedExample1 example2 = new SynchronizedExample1();
		ExecutorService executorService = Executors.newCachedThreadPool();
		executorService.execute(() -&gt; {
				example1.test2(1);
		});
		executorService.execute(() -&gt; {
				example2.test2(2);
		});
}
</code></pre>
<pre><code>// 修饰一个类
public static void test1(int j) {
		synchronized (SynchronizedExample2.class) {
				for (int i = 0; i &lt; 10; i++) {
						log.info(&quot;test1 {} - {}&quot;, j, i);
				}
		}
}

// 修饰一个静态方法
public static synchronized void test2(int j) {
		for (int i = 0; i &lt; 10; i++) {
				log.info(&quot;test2 {} - {}&quot;, j, i);
		}
}

public static void main(String[] args) {
		SynchronizedExample2 example1 = new SynchronizedExample2();
		SynchronizedExample2 example2 = new SynchronizedExample2();
		ExecutorService executorService = Executors.newCachedThreadPool();
		executorService.execute(() -&gt; {
				example1.test1(1);
		});
		executorService.execute(() -&gt; {
				example2.test1(2);
		});
}
</code></pre>
<p>Java provide several thread safe synchronized containers out of the box.</p>
<pre><code>private static List&lt;Integer&gt; list = Collections.synchronizedList(Lists.newArrayList());
private static Set&lt;Integer&gt; set = Collections.synchronizedSet(Sets.newHashSet());
private static Map&lt;Integer, Integer&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;());
private static Map&lt;Integer, Integer&gt; map = new Hashtable&lt;&gt;();
private static List&lt;Integer&gt; list = new Vector&lt;&gt;();
</code></pre>
<p>Java and Guava also provide several immutable containers out of the box.</p>
<pre><code>private static Map&lt;Integer, Integer&gt; map = Maps.newHashMap();
static {
		map.put(1, 2);
		map.put(3, 4);
		map.put(5, 6);
		map = Collections.unmodifiableMap(map);
}
</code></pre>
<pre><code>import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
private final static ImmutableList&lt;Integer&gt; list = ImmutableList.of(1, 2, 3);
private final static ImmutableSet set = ImmutableSet.copyOf(list);
private final static ImmutableMap&lt;Integer, Integer&gt; map = ImmutableMap.of(1, 2, 3, 4);
private final static ImmutableMap&lt;Integer, Integer&gt; map2 = ImmutableMap.&lt;Integer, Integer&gt;builder()
				.put(1, 2).put(3, 4).put(5, 6).build();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Contributing to Scala zio, a github open source project]]></title>
        <id>https://ywang412.github.io/post/contributing-to-a-scala-zio-a-github-open-source-project</id>
        <link href="https://ywang412.github.io/post/contributing-to-a-scala-zio-a-github-open-source-project">
        </link>
        <updated>2019-06-23T04:54:56.000Z</updated>
        <content type="html"><![CDATA[<p>I've hoped to contribute to open source project on github to be a part of the open source community and become a better developer. Today my two pull requests to a high profile scala repository, zio, got approved and I am very excited. The friendly and encouraging github community brought me a great experience.</p>
<p>These are the two pull requests that I made.</p>
<p>https://github.com/zio/zio/pull/1109
and
https://github.com/zio/zio/pull/1106</p>
<p>The first one is to deprecate a FiberLocal class.
<img src="https://ywang412.github.io/post-images/1561874927019.png" alt="">
The second one is to fix a bug resulting from different Windows/Linux file seperator.
<img src="https://ywang412.github.io/post-images/1561874992932.png" alt=""></p>
<p>The zio scala repository is very well maintained with decent test coverage and CD/CI pipeline. Thanks to the project maintainers for their huge efforts.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Coding tricks using Scala syntax]]></title>
        <id>https://ywang412.github.io/post/coding-tricks-of-scala-syntax</id>
        <link href="https://ywang412.github.io/post/coding-tricks-of-scala-syntax">
        </link>
        <updated>2019-01-17T02:49:08.000Z</updated>
        <content type="html"><![CDATA[<p>Underscore, &quot;_&quot;, can mean differents things in scala, such as default pattern matching, anonymous function, package import. There are some less frequently used cases that are worth mentioning. For example, _ can be used to maker a setter for a private variable.</p>
<pre><code>class Test {
   private var a = 0
   def age = a
   def age_=(n:Int) = {
      require(n&gt;0)
      a = n
   }
}
val t = new Test
t.age = 5
</code></pre>
<p>_ can convert a method to a function variable without actually invoking the method.</p>
<pre><code>class Test {
  def fun = {
    // some code
  }
  val funLike = fun _
}
</code></pre>
<p>To sort a List of object, java provide Comparator<T> interface to compare two objects. Scala used the Ordering[T] trait.</p>
<pre><code>case class Employee(id: Int, firstName: String, lastName: String)
object Employee {
  // Note that because `Ordering[A]` is not contravariant, the declaration
  // must be type-parametrized in the event that you want the implicit
  // ordering to apply to subclasses of `Employee`.
  implicit def orderingByName[A &lt;: Employee]: Ordering[A] = Ordering.by(e =&gt; (e.lastName, e.firstName))
  val orderingById: Ordering[Employee] = Ordering.by(e =&gt; e.id)
}
</code></pre>
<p>Given es: SeqLike[Employee], es.sorted() will sort by name, and es.sorted(Employee.orderingById) will sort by id.</p>
<p>Implicit val can be used to define the ordering mechanism as below,</p>
<pre><code>implicit val timestampordering: ordering[Timestamp] = Ordering.by(_.ts)
</code></pre>
<p>Scala flatmap() and for-comprehension are interchangable. For example,</p>
<pre><code>for {
  bound &lt;- list
  out &lt;- f(bound)
} yield out

// is translated by the Scala compiler as  
list.flatMap { bound =&gt;
  f(bound).map { out =&gt;
    out
  }
}
</code></pre>
<p>It is easy to figure out a recursive solution which tries to flat each element in a nested list. The problem is how to aggregate the integers and List[Int] into a new list. Foldleft() with an initial empty list will work but a more elegant solution is to create an one element list if the element is an integer. Below is the comparison.</p>
<p>Foldleft</p>
<pre><code>object FlattenArray {
  def flatten(list : List[Any]) : List[Int] = {
    list.foldLeft(List[Int]()){
      (res, cur) =&gt; {
        cur match {
          case null =&gt; res
          case cur: Int =&gt; res :+ cur
          case cur: List[Any] =&gt; res ::: flatten(cur)
        }
      }
    }
  }
}
</code></pre>
<p>Create single element list</p>
<pre><code>object FlattenArray {
  def flatten(input: List[_]): List[_] =
    input
      .filterNot(_ == null)
      .flatMap {
        case list: List[_] =&gt; flatten(list)
        case elem =&gt; List(elem)
      }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Examples of OOD class diagrams]]></title>
        <id>https://ywang412.github.io/post/examples-of-ood-class-diagrams</id>
        <link href="https://ywang412.github.io/post/examples-of-ood-class-diagrams">
        </link>
        <updated>2018-07-12T03:38:58.000Z</updated>
        <content type="html"><![CDATA[<p>Shopping
<img src="https://ywang412.github.io/post-images/1561869983328.png" alt="">
Parking
<img src="https://ywang412.github.io/post-images/1561693897171.png" alt="">
Library
<img src="https://ywang412.github.io/post-images/1561693905367.png" alt="">
StackOverflow
<img src="https://ywang412.github.io/post-images/1562126076022.png" alt="">
Movie
<img src="https://ywang412.github.io/post-images/1562126239722.png" alt="">
Flight
<img src="https://ywang412.github.io/post-images/1562126309435.png" alt="">
ATM
<img src="https://ywang412.github.io/post-images/1562126330414.png" alt="">
BlackJack
<img src="https://ywang412.github.io/post-images/1562127573365.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Coding tricks using Java syntax ]]></title>
        <id>https://ywang412.github.io/post/leetcode-118-pascals-triangle-java-type-erasure</id>
        <link href="https://ywang412.github.io/post/leetcode-118-pascals-triangle-java-type-erasure">
        </link>
        <updated>2018-06-13T04:49:32.000Z</updated>
        <content type="html"><![CDATA[<p>LeetCode has greatly sharpened my programming skills. A few examples are listed here.</p>
<p><strong>LeetCode 118</strong> Pascal's Triangle<br>
Due to Java type erasure, in order to instantiate a list of list, one can use
<code>List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</code>
or
<code>List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();</code>
Here <code>List&lt;Integer&gt;</code> becomes type definition.</p>
<p><strong>LeetCode 929</strong> requires removing of &quot;.&quot; in a string. It turns out &quot;.&quot; and &quot;*&quot; are metaCharacters used in a regex. From JDK 7 manual, the replaceAll() takes regex input and therefore &quot;.&quot; was recognized  as &quot;any character&quot;. Two backward slashes will escape dot character. Yet it is OK to use replace() API which can treat the &quot;.&quot; as a dot character.</p>
<p><em>JDK7</em></p>
<pre><code>String	replace(char oldChar, char newChar)
Returns a new string resulting from replacing all occurrences of oldChar in this string with newChar.
String	replaceAll(String regex, String replacement)
Replaces each substring of this string that matches the given regular expression with the given replacement.
String	replaceFirst(String regex, String replacement)
Replaces the first substring of this string that matches the given regular expression with the given replacement.
</code></pre>
<p>The solution is below,</p>
<pre><code>class Solution {
    public static int numUniqueEmails(String[] emails) {
        if (emails.length &lt; 1) return 0;

        Set&lt;String&gt; set = new HashSet&lt;&gt;();
        for (String email : emails) {
            String[] adds = email.split(&quot;@&quot;);
            String name = adds[0]; 
            if (name.indexOf(&quot;+&quot;) &gt;= 0) name = name.substring(0, name.indexOf(&quot;+&quot;));
            name = name.replaceAll(&quot;\\.&quot;,&quot;&quot;);
            set.add(name + &quot;@&quot; + adds[1]);
        }
        return set.size();
    }

    public static void main(String[] args) {
        String[] t = new String[]{&quot;testemail@leetcode.com&quot;,&quot;testemail1@leetcode.com&quot;,&quot;testemail+david@lee.tcode.com&quot;};
        System.out.println(numUniqueEmails(t));
    }
}
</code></pre>
<p><strong>LeetCode 791. Custom Sort String</strong>
Below is the code snippet to create a priorityqueue with custom comparator.</p>
<pre><code>			PriorityQueue&lt;Character&gt; queue = new PriorityQueue&lt;&gt;(new Comparator&lt;Character&gt;(){
					public int compare(Character a, Character b) {
							return Integer.compare(map.getOrDefault(a, Integer.MAX_VALUE), map.getOrDefault(b, Integer.MAX_VALUE));
					}
			});
</code></pre>
<p><strong>LeetCode 957. Prison Cells After N Days</strong></p>
<p>The state change cycle might start at a state that is not the initital state, therefore a map is used to record past state at each day. When fastforward the N using N % cycle, the N could already be 0 and the last state change should be skipped.</p>
<pre><code>while (N &gt; 0) { 
		StringBuilder sb = new StringBuilder();
		for (int j : cells) sb.append(j);
		if (map.containsKey(sb.toString())) {
				N %= (N - map.get(sb.toString()));
		}
		map.put(sb.toString(), N);
		if (N &gt;= 1) {
				N--;
				cells = prisonAfter1Day(cells);
		}
}
</code></pre>
<p><strong>LeetCode 957. K Empty Slots</strong></p>
<p>Java Primitive types such as &quot;int&quot; are not nullable. Boxed version such as &quot;Integer&quot; are nullable. Therefore, when get nullable value from Java collections, the null check can only performed on the boxed data type.</p>
<pre><code>TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;();
Integer low = set.floor(bulbs[i]);
Integer high = set.ceiling(bulbs[i]);
if (low != null &amp;&amp; bulbs[i] - low - 1 == K) return i + 1;
if (high != null &amp;&amp; high - bulbs[i] - 1 == K) return i + 1;            
</code></pre>
<p><strong>402. Remove K Digits</strong>
To remove the leading zeros in a string, regex match by &quot;^0*&quot; is the shortcut. A more verbose way is to break the for-loop at the first non-zero Char.</p>
<pre><code>for (int i = 0; i &lt; source.length(); ++i) {
		char c = source.charAt(i);
		if (c != '0') {
				return source.substring(i);
		}
}
return &quot;&quot;; // or return &quot;0&quot;;
</code></pre>
<pre><code>while(sb.length()&gt;1 &amp;&amp; sb.charAt(0)=='0')
		sb.deleteCharAt(0);
return sb.toString();
</code></pre>
<pre><code>String s = &quot;00000000&quot;;
s = s.replaceFirst (&quot;^0*&quot;, &quot;&quot;);
if (s.isEmpty()) s = &quot;0&quot;;
</code></pre>
<p><strong>1027. Longest Arithmetic Sequence</strong></p>
<p>The syntax to create a array of Hashmap is</p>
<p><code>HashMap&lt;Integer, Integer&gt;[] dp = new HashMap[n];</code></p>
<p><strong>1027. Multiply Strings</strong></p>
<p>The underlying data structure is a int[] of which each element is a single digit number representing the number at that position. However, when adding the product to the int[], it is important to keep the element to be single digit. To convert single digit to Char, one can use <em>(char)(dig + '0')</em></p>
<pre><code>public String multiply(String num1, String num2) {
		int[] p = new int[num1.length() + num2.length()];
		for (int i = num1.length() - 1; i &gt;= 0; i--) {
				for (int j = num2.length() - 1; j &gt;= 0; j--) {
						int multiply = (num1.charAt(i) - '0') * (num2.charAt(j) - '0');
						int sum = multiply + p[i+j+1];
						p[i+j+1] = sum % 10;
						p[i+j] += sum / 10;
				}
		}
		StringBuilder sb = new StringBuilder();
		for (int dig : p) {
				if (!(sb.length() == 0 &amp;&amp; dig == 0)) {
						sb.append((char)(dig + '0'));
				}
		}
		return sb.length() == 0? &quot;0&quot;:sb.toString();
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Pitfalls in DFS and BFS algorithm]]></title>
        <id>https://ywang412.github.io/post/dfsbfs-algorithm</id>
        <link href="https://ywang412.github.io/post/dfsbfs-algorithm">
        </link>
        <updated>2018-05-17T20:03:19.000Z</updated>
        <content type="html"><![CDATA[<p>Some pitfalls in DFS/BFS algorithm that requires extra caution.</p>
<p><strong>Leetcode 542. 01 Matrix</strong></p>
<p>To find the shortest distance from 1 to nearest 0, It is important to truncate when current dist from a 0 is already larger than previous found dfs path originated from another 0.</p>
<pre><code>public void dfs(int[][] res, boolean[][] visited, int i, int j, int dist) {
        if (i &lt; 0 || i &gt;= res.length || j &lt; 0 || j &gt;= res[0].length || res[i][j] &lt;= dist) return;
        res[i][j] = Math.min(dist, res[i][j]);
        visited[i][j] = true;
        dfs(res, visited, i - 1, j, dist + 1);
        dfs(res, visited, i + 1, j, dist + 1);
        dfs(res, visited, i, j - 1, dist + 1);
        dfs(res, visited, i, j + 1, dist + 1); 
        visited[i][j] = false;
    }
</code></pre>
<p><strong>LeetCode 39. Combination Sum</strong>
Because of passing by reference, when adding a path to result list, the added path is a deep copy to avoid further changes. To prevent duplicated path, each dfs entry will set the minimum index of the range that following dfs can choose from.</p>
<pre><code>public void dfs(int[] candidates, int start, int cur, int target, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res) {
     if (cur &gt; target) return;
     if (cur == target) { 
         List&lt;Integer&gt; pathToAdd = new LinkedList&lt;&gt;(path);
         res.add(pathToAdd);
         return;
     }
     for (int i = start; i &lt; candidates.length; i++) {
         path.add(candidates[i]);
         dfs(candidates, i, cur + candidates[i], target, path, res);
         path.remove(path.size() - 1);
     }
</code></pre>
<p><strong>LeetCode 675. Cut Off Trees for Golf Event</strong>
Whenever a new position is added to the BFS queue, the visited matrix or set need to mark that as soon as possible to avoid revisiting it. Comparing string (Char of 2 bytes) is much more time consuming than comparing Integer (4 bytes).</p>
<pre><code>public int bfs(int[] pre, int[] cur, List&lt;List&lt;Integer&gt;&gt; forest) {  
		Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;();
		Set&lt;String&gt; visited = new HashSet&lt;&gt;();
		pre[2] = 0;
		q.offer(pre); 
		visited.add(pre[0] + &quot;#&quot; + pre[1]);
		while (!q.isEmpty()) {   
				int[] temp = q.poll(); 
				// if ((temp[0] + &quot;#&quot; + temp[1]).equals(cur[0] + &quot;#&quot; + cur[1])) { this will cause timeout
				if ((temp[0] == cur[0]) &amp;&amp; (temp[1] == cur[1])) {
						return temp[2];
				}
				else {
						for (int[] dir : dirs) {
								int i = temp[0] + dir[0];
								int j = temp[1] + dir[1];
								if (i &gt;= 0 &amp;&amp; i &lt; forest.size() &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; forest.get(i).size() &amp;&amp; forest.get(i).get(j) &gt; 0 &amp;&amp; !visited.contains(i + &quot;#&quot; + j)) {
										q.offer(new int[]{i, j, temp[2] + 1});
										visited.add(i + &quot;#&quot; + j);
								}
						}
				} 
		}
		return -1;
}
</code></pre>
]]></content>
    </entry>
</feed>