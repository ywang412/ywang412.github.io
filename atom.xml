<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ywang412.github.io</id>
    <title>Yu&apos;s Github</title>
    <updated>2019-08-12T03:16:45.992Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ywang412.github.io"/>
    <link rel="self" href="https://ywang412.github.io/atom.xml"/>
    <subtitle>Java by day, Scala by night</subtitle>
    <logo>https://ywang412.github.io/images/avatar.png</logo>
    <icon>https://ywang412.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Yu&apos;s Github</rights>
    <entry>
        <title type="html"><![CDATA[DP summary]]></title>
        <id>https://ywang412.github.io/post/dp-summary</id>
        <link href="https://ywang412.github.io/post/dp-summary">
        </link>
        <updated>2019-08-02T07:37:53.000Z</updated>
        <content type="html"><![CDATA[<ol start="375">
<li>Guess Number Higher or Lower II</li>
<li>Best Time to Buy and Sell Stock IV</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Monotonic Stack]]></title>
        <id>https://ywang412.github.io/post/monotonic-stack</id>
        <link href="https://ywang412.github.io/post/monotonic-stack">
        </link>
        <updated>2019-07-30T02:40:22.000Z</updated>
        <content type="html"><![CDATA[<p><strong>739. Daily Temperatures and 496. Next Greater Element I</strong></p>
<pre><code>class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        int[] ret = new int[temperatures.length];
        for(int i = 0; i &lt; temperatures.length; i++) {
            while(!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) {
                int idx = stack.pop();
                ret[idx] = i - idx;
            }
            stack.push(i);
        }
        return ret;
    }
}
</code></pre>
<p><strong>Largest Rectangle in Histogram</strong></p>
<pre><code>public class Solution {
    public int largestRectangleArea(int[] height) {
        int len = height.length;
        Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;();
        int maxArea = 0;
        int i = 0;
        while(i &lt;= len){
            int h = (i == len ? 0 : height[i]);
            if(s.isEmpty() || h &gt;= height[s.peek()]){
                s.push(i);
                i++;
            }else{
                int tp = s.pop();
                maxArea = Math.max(maxArea, height[tp] * (s.isEmpty() ? i : i - 1 - s.peek()));
                 
            }
        }
        return maxArea;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Quick sort, quick select and merge sort]]></title>
        <id>https://ywang412.github.io/post/quick-sort-quick-select-and-merge-sort</id>
        <link href="https://ywang412.github.io/post/quick-sort-quick-select-and-merge-sort">
        </link>
        <updated>2019-07-28T00:09:43.000Z</updated>
        <content type="html"><![CDATA[<p><strong>215. Kth Largest Element in an Array</strong></p>
<pre><code>class Solution {
    public int findKthLargest(int[] nums, int k) {
        return quickSelectK(nums, 0, nums.length - 1, nums.length - k);
    }
    
    public int quickSelectK(int[] nums, int start, int end, int k) { 
        
        int pivot = nums[start];
        int i = start;
        int j = end;
        while (i &lt; j) { 
            while (i &lt; end &amp;&amp; nums[i] &lt;= pivot) i++;
            while (j &gt; start &amp;&amp; nums[j] &gt;= pivot) j--; 
            if (i &lt; j) {
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
            }   
        } 
        nums[start] = nums[j];
        nums[j] = pivot;
        if (j == k) return nums[j];
        else if (j &lt; k) return quickSelectK(nums, j + 1, end, k);
        else return quickSelectK(nums, start, j, k);
    } 
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java JUC (java.util.concurrent) 5 - ThreadPool and ThreadLocal]]></title>
        <id>https://ywang412.github.io/post/java-juc-javautilconcurrent-5-threadpool-and-threadlocal</id>
        <link href="https://ywang412.github.io/post/java-juc-javautilconcurrent-5-threadpool-and-threadlocal">
        </link>
        <updated>2019-07-07T01:19:02.000Z</updated>
        <content type="html"><![CDATA[<p>Java use Thread Pool pattern to save resources in a multithreaded application, and also to contain the parallelism in certain predefined limits. It controls several re-used threads for executing these tasks.</p>
<pre><code>ExecutorService executorService = Executors.newCachedThreadPool();
for (int i = 0; i &lt; 10; i++) {
		final int index = i;
		executorService.execute(new Runnable() {
				@Override
				public void run() {
						log.info(&quot;task:{}&quot;, index);
				}
		});
}
executorService.shutdown();
</code></pre>
<p>There are several pre-defined threadpool for various scenarios.</p>
<pre><code>ExecutorService executorService = Executors.newFixedThreadPool(3);
ExecutorService executorService = Executors.newSingleThreadExecutor();
ScheduledExecutorService executorService = Executors.newScheduledThreadPool(1);
</code></pre>
<p>The TheadLocal construct allows us to store data that will be accessible only by a specific thread.</p>
<pre><code>private final static ThreadLocal&lt;Long&gt; requestHolder = new ThreadLocal&lt;&gt;();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java JUC (java.util.concurrent) 4 - Lock]]></title>
        <id>https://ywang412.github.io/post/java-juc-javautilconcurrent-2-lock</id>
        <link href="https://ywang412.github.io/post/java-juc-javautilconcurrent-2-lock">
        </link>
        <updated>2019-07-03T17:07:58.000Z</updated>
        <content type="html"><![CDATA[<p>Compare to <code>synchronized</code> keyword, Locks support various methods for finer grained control thus are more expressive than <code>synchronized</code>.</p>
<p>Since <code>synchronized</code> keyword create lock implicitly, one can convert the  <code>synchronized</code> keyword to ReentrantLock.</p>
<pre><code>private synchronized static void add() {
        count++;
}
</code></pre>
<pre><code>private final static Lock lock = new ReentrantLock();
private static void add() {
		lock.lock();
		try {
				count++;
		} finally {
				lock.unlock();
		}
}
</code></pre>
<p>Therefore, it is possible for both <code>synchronized</code> and Lock to introduce the well-know deadlock problem like below.</p>
<pre><code>public class DeadLock implements Runnable {
    public int flag = 1;
    //静态对象是类的所有对象共享的
    private static Object o1 = new Object(), o2 = new Object();

    @Override
    public void run() {
        log.info(&quot;flag:{}&quot;, flag);
        if (flag == 1) {
            synchronized (o1) {
                try {
                    Thread.sleep(500);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                synchronized (o2) {
                    log.info(&quot;1&quot;);
                }
            }
        }
        if (flag == 0) {
            synchronized (o2) {
                try {
                    Thread.sleep(500);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                synchronized (o1) {
                    log.info(&quot;0&quot;);
                }
            }
        }
    }

    public static void main(String[] args) {
        DeadLock td1 = new DeadLock();
        DeadLock td2 = new DeadLock();
        td1.flag = 1;
        td2.flag = 0;
        //td1,td2都处于可执行状态，但JVM线程调度先执行哪个线程是不确定的。
        //td2的run()可能在td1的run()之前运行
        new Thread(td1).start();
        new Thread(td2).start();
    }
}
</code></pre>
<p>The <code>synchronized</code> keyword provides a simplified model while Lock offers more APIs such as ReentrantReadWriteLock and Condition. The interface ReadWriteLock specifies a pair of locks for read and write access. This can improve performance and throughput in cases where write-accesses are much less frequent.</p>
<pre><code>private final Map&lt;String, Data&gt; map = new TreeMap&lt;&gt;();

private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
private final Lock readLock = lock.readLock();
private final Lock writeLock = lock.writeLock();

public Data get(String key) {
		readLock.lock();
		try {
				return map.get(key);
		} finally {
				readLock.unlock();
		}
}

public Data put(String key, Data value) {
		writeLock.lock();
		try {
				return map.put(key, value);
		} finally {
				writeLock.unlock();
		}
}
</code></pre>
<p><code>Condition.signalAll()</code> is a very important API in consumer-producer model.</p>
<pre><code>public static void main(String[] args) {
		ReentrantLock reentrantLock = new ReentrantLock();
		Condition condition = reentrantLock.newCondition();

		new Thread(() -&gt; {
				try {
						reentrantLock.lock();
						log.info(&quot;wait signal&quot;); // 1
						condition.await();
				} catch (InterruptedException e) {
						e.printStackTrace();
				}
				log.info(&quot;get signal&quot;); // 4
				reentrantLock.unlock();
		}).start();

		new Thread(() -&gt; {
				reentrantLock.lock();
				log.info(&quot;get lock&quot;); // 2
				try {
						Thread.sleep(3000);
				} catch (InterruptedException e) {
						e.printStackTrace();
				}
				condition.signalAll();
				log.info(&quot;send signal ~ &quot;); // 3
				reentrantLock.unlock();
		}).start();
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Contributing to Scala zio, a github open source project]]></title>
        <id>https://ywang412.github.io/post/contributing-to-a-scala-zio-a-github-open-source-project</id>
        <link href="https://ywang412.github.io/post/contributing-to-a-scala-zio-a-github-open-source-project">
        </link>
        <updated>2019-06-23T04:54:56.000Z</updated>
        <content type="html"><![CDATA[<p>I've hoped to contribute to open source project on github to be a part of the open source community and become a better developer. Today my two pull requests to a high profile scala repository, zio, got approved and I am very excited. The friendly and encouraging github community brought me a great experience.</p>
<p>These are the two pull requests that I made.</p>
<p>https://github.com/zio/zio/pull/1109
and
https://github.com/zio/zio/pull/1106</p>
<p>The first one is to deprecate a FiberLocal class.
<img src="https://ywang412.github.io/post-images/1561874927019.png" alt="">
The second one is to fix a bug resulting from different Windows/Linux file seperator.
<img src="https://ywang412.github.io/post-images/1561874992932.png" alt=""></p>
<p>The zio scala repository is very well maintained with decent test coverage and CD/CI pipeline. Thanks to the project maintainers for their huge efforts.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java JUC (java.util.concurrent) 3 - Synchronized and Synchronized Container]]></title>
        <id>https://ywang412.github.io/post/java-juc-javautilconcurrent-3-synchronzied-and-synchronzied-container</id>
        <link href="https://ywang412.github.io/post/java-juc-javautilconcurrent-3-synchronzied-and-synchronzied-container">
        </link>
        <updated>2019-05-14T11:31:10.000Z</updated>
        <content type="html"><![CDATA[<p><code>Synchronized</code> keyword bounds monitor to an object and has made concurrency programing simple. It can be added to method or object to achieve object level synchronization. It can also modify static method or class for class level synchronization.</p>
<pre><code>// 修饰一个代码块
public void test1(int j) {
		synchronized (this) {
				for (int i = 0; i &lt; 10; i++) {
						log.info(&quot;test1 {} - {}&quot;, j, i);
				}
		}
}

// 修饰一个方法
public synchronized void test2(int j) {
		for (int i = 0; i &lt; 10; i++) {
				log.info(&quot;test2 {} - {}&quot;, j, i);
		}
}

public static void main(String[] args) {
		SynchronizedExample1 example1 = new SynchronizedExample1();
		SynchronizedExample1 example2 = new SynchronizedExample1();
		ExecutorService executorService = Executors.newCachedThreadPool();
		executorService.execute(() -&gt; {
				example1.test2(1);
		});
		executorService.execute(() -&gt; {
				example2.test2(2);
		});
}
</code></pre>
<pre><code>// 修饰一个类
public static void test1(int j) {
		synchronized (SynchronizedExample2.class) {
				for (int i = 0; i &lt; 10; i++) {
						log.info(&quot;test1 {} - {}&quot;, j, i);
				}
		}
}

// 修饰一个静态方法
public static synchronized void test2(int j) {
		for (int i = 0; i &lt; 10; i++) {
				log.info(&quot;test2 {} - {}&quot;, j, i);
		}
}

public static void main(String[] args) {
		SynchronizedExample2 example1 = new SynchronizedExample2();
		SynchronizedExample2 example2 = new SynchronizedExample2();
		ExecutorService executorService = Executors.newCachedThreadPool();
		executorService.execute(() -&gt; {
				example1.test1(1);
		});
		executorService.execute(() -&gt; {
				example2.test1(2);
		});
}
</code></pre>
<p>Java provide several thread safe synchronized containers out of the box.</p>
<pre><code>private static List&lt;Integer&gt; list = Collections.synchronizedList(Lists.newArrayList());
private static Set&lt;Integer&gt; set = Collections.synchronizedSet(Sets.newHashSet());
private static Map&lt;Integer, Integer&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;());
private static Map&lt;Integer, Integer&gt; map = new Hashtable&lt;&gt;();
private static List&lt;Integer&gt; list = new Vector&lt;&gt;();
</code></pre>
<p>Java and Guava also provide several immutable containers out of the box.</p>
<pre><code>private static Map&lt;Integer, Integer&gt; map = Maps.newHashMap();
static {
		map.put(1, 2);
		map.put(3, 4);
		map.put(5, 6);
		map = Collections.unmodifiableMap(map);
}
</code></pre>
<pre><code>import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
private final static ImmutableList&lt;Integer&gt; list = ImmutableList.of(1, 2, 3);
private final static ImmutableSet set = ImmutableSet.copyOf(list);
private final static ImmutableMap&lt;Integer, Integer&gt; map = ImmutableMap.of(1, 2, 3, 4);
private final static ImmutableMap&lt;Integer, Integer&gt; map2 = ImmutableMap.&lt;Integer, Integer&gt;builder()
				.put(1, 2).put(3, 4).put(5, 6).build();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java JUC (java.util.concurrent) 2 - Atomic Variables and Concurrent Collection]]></title>
        <id>https://ywang412.github.io/post/java-juc-javautilconcurrent-2-atomic-variables</id>
        <link href="https://ywang412.github.io/post/java-juc-javautilconcurrent-2-atomic-variables">
        </link>
        <updated>2019-04-25T01:22:48.000Z</updated>
        <content type="html"><![CDATA[<p>Atomic varaibles are important parts of java concurrency API. It allows multiple threads safely access the same variables. The java.util.concurrent.atomic classes heavily used compare-and-swap (CAS) technique. CAS happens at CPU instruction level and is much more light weighted than synchronizing through locks or <code>synchronized</code> key word.</p>
<p>AtomicInteger, AtomicLong, LongAdder, AtomicBoolean, and AtomicReference<Integer> are some of the most used Atomic classes.</p>
<p><strong>AtomicInteger</strong></p>
<pre><code>// 请求总数
public static int clientTotal = 5000;
// 同时并发执行的线程数
public static int threadTotal = 200;
public static AtomicInteger count = new AtomicInteger(0);

public static void main(String[] args) throws Exception {
		ExecutorService executorService = Executors.newCachedThreadPool();
		final Semaphore semaphore = new Semaphore(threadTotal);
		final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);
		for (int i = 0; i &lt; clientTotal ; i++) {
				executorService.execute(() -&gt; {
						try {
								semaphore.acquire();
								add();
								semaphore.release();
						} catch (Exception e) {
								log.error(&quot;exception&quot;, e);
						}
						countDownLatch.countDown();
				});
		}
		countDownLatch.await();
		executorService.shutdown();
		log.info(&quot;count:{}&quot;, count.get());
}

private static void add() {
		count.incrementAndGet();
		// count.getAndIncrement();
}
</code></pre>
<p>Another way to acheive correct counting result like above is <code>synchronized</code> keyword.</p>
<pre><code>// 请求总数
public static int clientTotal = 5000;
// 同时并发执行的线程数
public static int threadTotal = 200;
public static int count = 0;

public static void main(String[] args) throws Exception {
		ExecutorService executorService = Executors.newCachedThreadPool();
		final Semaphore semaphore = new Semaphore(threadTotal);
		final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);
		for (int i = 0; i &lt; clientTotal ; i++) {
				executorService.execute(() -&gt; {
						try {
								semaphore.acquire();
								add();
								semaphore.release();
						} catch (Exception e) {
								log.error(&quot;exception&quot;, e);
						}
						countDownLatch.countDown();
				});
		}
		countDownLatch.await();
		executorService.shutdown();
		log.info(&quot;count:{}&quot;, count);
}

private synchronized static void add() {
		count++;
}
</code></pre>
<p>However, volatile keyword as in <code>public static volatile int count = 0;</code> will not be able to ensure threadsafety to due CPU instruction reorder.</p>
<p>ConcurrentHashMap, ConcurrentSkipListMap, ConcurrentSkipListSet, CopyOnWriteArrayList, CopyOnWriteArraySet are some typical concurrency collection classes in Java 8.</p>
<p><strong>CopyOnWriteArrayList</strong></p>
<pre><code>// 请求总数
public static int clientTotal = 5000;
// 同时并发执行的线程数
public static int threadTotal = 200;
private static List&lt;Integer&gt; list = new CopyOnWriteArrayList&lt;&gt;();

public static void main(String[] args) throws Exception {
		ExecutorService executorService = Executors.newCachedThreadPool();
		final Semaphore semaphore = new Semaphore(threadTotal);
		final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);
		for (int i = 0; i &lt; clientTotal; i++) {
				final int count = i;
				executorService.execute(() -&gt; {
						try {
								semaphore.acquire();
								update(count);
								semaphore.release();
						} catch (Exception e) {
								log.error(&quot;exception&quot;, e);
						}
						countDownLatch.countDown();
				});
		}
		countDownLatch.await();
		executorService.shutdown();
		log.info(&quot;size:{}&quot;, list.size());
}

private static void update(int i) {
		list.add(i);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java JUC (java.util.concurrent) 1 - AQS：AbstractQueuedSynchronizer]]></title>
        <id>https://ywang412.github.io/post/java-juc-javautilconcurrent-1-aqsabstractqueuedsynchronizer</id>
        <link href="https://ywang412.github.io/post/java-juc-javautilconcurrent-1-aqsabstractqueuedsynchronizer">
        </link>
        <updated>2019-04-09T19:02:16.000Z</updated>
        <content type="html"><![CDATA[<p>AbstractQueuedSynchronizer lays the foundation of java JUC programming. Concurrency classes are extensively using Sync class which extends from AQS as shown below.</p>
<p><img src="https://ywang412.github.io/post-images/1562476011734.png" alt=""></p>
<p>Some example code snippets of CountDownLatch, CyclicBarrier, Semaphore, ForkJoinTask, and FutureTask are explained here.</p>
<p><strong>CountDownLatch</strong></p>
<pre><code>public static void main(String[] args) throws Exception {
		ExecutorService exec = Executors.newCachedThreadPool();
		final CountDownLatch countDownLatch = new CountDownLatch(threadCount);
		for (int i = 0; i &lt; threadCount; i++) {
				final int threadNum = i;
				exec.execute(() -&gt; {
						try {
								test(threadNum);
						} catch (Exception e) {
								log.error(&quot;exception&quot;, e);
						} finally {
								countDownLatch.countDown();
						}
				});
		}
		countDownLatch.await(10, TimeUnit.MILLISECONDS);
		log.info(&quot;finish&quot;);
		exec.shutdown();
}

private static void test(int threadNum) throws Exception {
		Thread.sleep(100);
		log.info(&quot;{}&quot;, threadNum);
}
</code></pre>
<p><strong>CyclicBarrier</strong></p>
<pre><code>private static CyclicBarrier barrier = new CyclicBarrier(5);

public static void main(String[] args) throws Exception {
		ExecutorService executor = Executors.newCachedThreadPool();
		for (int i = 0; i &lt; 10; i++) {
				final int threadNum = i;
				Thread.sleep(1000);
				executor.execute(() -&gt; {
						try {
								race(threadNum);
						} catch (Exception e) {
								log.error(&quot;exception&quot;, e);
						}
				});
		}
		executor.shutdown();
}

private static void race(int threadNum) throws Exception {
		Thread.sleep(1000);
		log.info(&quot;{} is ready&quot;, threadNum);
		barrier.await();
		log.info(&quot;{} continue&quot;, threadNum);
}
</code></pre>
<p><strong>Semaphore</strong></p>
<pre><code>ExecutorService exec = Executors.newCachedThreadPool();
final Semaphore semaphore = new Semaphore(3);

for (int i = 0; i &lt; threadCount; i++) {
		final int threadNum = i;
		exec.execute(() -&gt; {
				try {
						if (semaphore.tryAcquire(5000, TimeUnit.MILLISECONDS)) { // 尝试获取一个许可
								test(threadNum);
								semaphore.release(); // 释放一个许可
						}
				} catch (Exception e) {
						log.error(&quot;exception&quot;, e);
				}
		});
}
exec.shutdown();
}

private static void test(int threadNum) throws Exception {
log.info(&quot;{}&quot;, threadNum);
Thread.sleep(1000);
}
</code></pre>
<p><strong>ForkJoinTask</strong></p>
<pre><code>public class ForkJoinTaskExample extends RecursiveTask&lt;Integer&gt; {

    public static final int threshold = 2;
    private int start;
    private int end;

    public ForkJoinTaskExample(int start, int end) {
        this.start = start;
        this.end = end;
    }

    @Override
    protected Integer compute() {
        int sum = 0;

        //如果任务足够小就计算任务
        boolean canCompute = (end - start) &lt;= threshold;
        if (canCompute) {
            for (int i = start; i &lt;= end; i++) {
                sum += i;
            }
        } else {
            // 如果任务大于阈值，就分裂成两个子任务计算
            int middle = (start + end) / 2;
            ForkJoinTaskExample leftTask = new ForkJoinTaskExample(start, middle);
            ForkJoinTaskExample rightTask = new ForkJoinTaskExample(middle + 1, end);

            // 执行子任务
            leftTask.fork();
            rightTask.fork();

            // 等待任务执行结束合并其结果
            int leftResult = leftTask.join();
            int rightResult = rightTask.join();

            // 合并子任务
            sum = leftResult + rightResult;
        }
        return sum;
    }

    public static void main(String[] args) {
        ForkJoinPool forkjoinPool = new ForkJoinPool();

        //生成一个计算任务，计算1+2+3+4
        ForkJoinTaskExample task = new ForkJoinTaskExample(1, 100);

        //执行一个任务
        Future&lt;Integer&gt; result = forkjoinPool.submit(task);

        try {
            log.info(&quot;result:{}&quot;, result.get());
        } catch (Exception e) {
            log.error(&quot;exception&quot;, e);
        }
    }
}
</code></pre>
<p><strong>Future</strong></p>
<pre><code>static class MyCallable implements Callable&lt;String&gt; {

        @Override
        public String call() throws Exception {
            log.info(&quot;do something in callable&quot;);
            Thread.sleep(5000);
            return &quot;Done&quot;;
        }
    }

    public static void main(String[] args) throws Exception {
        ExecutorService executorService = Executors.newCachedThreadPool();
        Future&lt;String&gt; future = executorService.submit(new MyCallable());
        log.info(&quot;do something in main&quot;);
        Thread.sleep(1000);
        String result = future.get();
        log.info(&quot;result：{}&quot;, result);
    }
</code></pre>
<p><strong>FutureTask</strong></p>
<pre><code>public static void main(String[] args) throws Exception {
		FutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(new Callable&lt;String&gt;() {
				@Override
				public String call() throws Exception {
						log.info(&quot;do something in callable&quot;);
						Thread.sleep(5000);
						return &quot;Done&quot;;
				}
		});

		new Thread(futureTask).start();
		log.info(&quot;do something in main&quot;);
		Thread.sleep(1000);
		String result = futureTask.get();
		log.info(&quot;result：{}&quot;, result);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Perfect Singleton?]]></title>
        <id>https://ywang412.github.io/post/perfect-singleton</id>
        <link href="https://ywang412.github.io/post/perfect-singleton">
        </link>
        <updated>2019-03-20T12:30:24.000Z</updated>
        <content type="html"><![CDATA[<p>A singleton class is a class that can have only one object (an instance of the class) at a time.</p>
<p><strong>Eager initialization</strong> is the mostly straightforward approach.</p>
<pre><code>@ThreadSafe
public class SingletonExample2 {

    // 私有构造函数
    private SingletonExample2() {}

    // 单例对象
    private static SingletonExample2 instance = new SingletonExample2();

    // 静态的工厂方法
    public static SingletonExample2 getInstance() {
        return instance;
    }
}
</code></pre>
<p><strong>Lazy initialization</strong> by adding <code>synchronized</code> keyword to the getInstance method is quite inefficient.</p>
<pre><code>@ThreadSafe
@NotRecommend
public class SingletonExample3 {

    // 私有构造函数
    private SingletonExample3() {

    }

    // 单例对象
    private static SingletonExample3 instance = null;

    // 静态的工厂方法
    public static synchronized SingletonExample3 getInstance() {
        if (instance == null) {
            instance = new SingletonExample3();
        }
        return instance;
    }
}
</code></pre>
<p>However, we can move the initialization into a static block so instance is created with class loading.</p>
<pre><code>@ThreadSafe
public class SingletonExample6 {

    // 私有构造函数
    private SingletonExample6() {

    }

    // 单例对象
    private static SingletonExample6 instance = null;

    static {
        instance = new SingletonExample6();
    }

    // 静态的工厂方法
    public static SingletonExample6 getInstance() {
        return instance;
    }

    public static void main(String[] args) {
        System.out.println(getInstance().hashCode());
        System.out.println(getInstance().hashCode());
    }
}
</code></pre>
<p>To make <strong>Lazy initialization</strong> more efficient, it requires both double check locking method and <code>volatile</code> keyword to avoid CPU instruction reorder.</p>
<pre><code>@ThreadSafe
public class SingletonExample5 {

    // 私有构造函数
    private SingletonExample5() {

    }

    // 1、memory = allocate() 分配对象的内存空间
    // 2、ctorInstance() 初始化对象
    // 3、instance = memory 设置instance指向刚分配的内存

    // 单例对象 volatile + 双重检测机制 -&gt; 禁止指令重排
    private volatile static SingletonExample5 instance = null;

    // 静态的工厂方法
    public static SingletonExample5 getInstance() {
        if (instance == null) { // 双重检测机制        // B
            synchronized (SingletonExample5.class) { // 同步锁
                if (instance == null) {
                    instance = new SingletonExample5(); // A - 3
                }
            }
        }
        return instance;
    }
}
</code></pre>
<p>Finally, we can use enumeration approach. It has serialization and thread-safety guaranteed by the enum implementation itself, which ensures internally that only the single instance is available, correcting the problems pointed out in the class-based implementation.</p>
<pre><code>@ThreadSafe
@Recommend
public class SingletonExample7 {

    // 私有构造函数
    private SingletonExample7() {

    }

    public static SingletonExample7 getInstance() {
        return Singleton.INSTANCE.getInstance();
    }

    private enum Singleton {
        INSTANCE;

        private SingletonExample7 singleton;

        // JVM保证这个方法绝对只调用一次
        Singleton() {
            singleton = new SingletonExample7();
        }

        public SingletonExample7 getInstance() {
            return singleton;
        }
    }
}
</code></pre>
]]></content>
    </entry>
</feed>